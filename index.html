<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
  <title>Прогнозы на футбол — Тур</title>
  <script src="https://unpkg.com/react@18.2.0/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone@7.22.9/babel.min.js"></script>
  <!-- Firebase (compat) -->
  <script src="https://www.gstatic.com/firebasejs/10.12.5/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore-compat.js"></script>
  <style>
    :root{
      --bg:#f5f7fb; --card:#fff; --text:#222; --muted:#667084;
      --brand:#0d6efd; --brand-2:#00bcd4; --ok:#19a974; --warn:#ff9800; --danger:#ef4444;
      --border:#e5e7eb; --shadow:0 6px 18px rgba(0,0,0,.06); --radius:14px; --radius-sm:10px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif;
      background:linear-gradient(135deg,#e8f0ff,#f8fbff 40%,#eefaf7);color:var(--text)
    }
    .wrap{max-width:1100px;margin:0 auto;padding:16px 12px 48px}
    header{display:flex;align-items:center;justify-content:space-between;gap:12px;margin:6px 0 14px;flex-wrap:wrap}
    h1{margin:0;font-size:22px;font-weight:800;letter-spacing:.2px;background:linear-gradient(45deg,var(--brand),var(--brand-2));-webkit-background-clip:text;-webkit-text-fill-color:transparent}
    .toolbar{display:flex;gap:8px;flex-wrap:wrap;align-items:center;width:100%}
    .round-name{display:flex;gap:8px;align-items:center;background:var(--card);border:1px solid var(--border);border-radius:999px;padding:8px 12px;box-shadow:var(--shadow);flex:1;min-width:220px}
    .round-name input{border:none;outline:none;font-size:14px;background:transparent;min-width:120px;width:100%}
    .cloud-box{display:flex;gap:8px;align-items:center;background:var(--card);border:1px solid var(--border);border-radius:999px;padding:8px 12px;box-shadow:var(--shadow);flex:1;min-width:220px}
    .cloud-box input{border:none;outline:none;font-size:14px;background:transparent;min-width:120px;width:100%}
    .tabs{display:flex;gap:8px;flex-wrap:nowrap;margin:4px 0 12px;overflow-x:auto;-webkit-overflow-scrolling:touch;padding-bottom:2px}
    .tabs::-webkit-scrollbar{display:none}
    .tab-btn{white-space:nowrap;border:1px solid var(--border);background:var(--card);padding:10px 14px;border-radius:999px;cursor:pointer;font-weight:600;color:var(--muted);flex:0 0 auto}
    .tab-btn.active{background:linear-gradient(45deg,var(--brand),var(--brand-2));color:#fff;border-color:transparent;box-shadow:var(--shadow)}
    .grid{display:grid;gap:12px}
    @media(min-width:900px){.grid-2{grid-template-columns:1.15fr .85fr}}
    .card{background:var(--card);border:1px solid var(--border);border-radius:var(--radius);box-shadow:var(--shadow);padding:12px}
    .card h2{margin:0 0 10px;font-size:18px}
    .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    .btn{border:none;border-radius:10px;padding:9px 12px;font-weight:700;cursor:pointer;display:inline-flex;gap:8px;align-items:center}
    .btn:disabled{opacity:.5;cursor:not-allowed}
    .btn-primary{background:linear-gradient(45deg,var(--brand),var(--brand-2));color:#fff;box-shadow:var(--shadow)}
    .btn-ghost{background:#fff;border:1px solid var(--border)}
    .btn-danger{background:linear-gradient(45deg,#ef5350,#ef4444);color:#fff}
    .btn-ok{background:linear-gradient(45deg,#22c55e,#16a34a);color:#fff}
    .chip{display:inline-flex;align-items:center;gap:6px;border:1px solid var(--border);border-radius:999px;padding:6px 10px;background:#fff;font-size:12px}
    .muted{color:var(--muted);font-size:12px}
    .table-wrap{width:100%;overflow-x:auto;-webkit-overflow-scrolling:touch}
    .table{width:100%;border-collapse:collapse;margin-top:6px;min-width:560px}
    .table-wide{min-width:760px}
    .table th,.table td{border-bottom:1px solid var(--border);padding:10px 8px;text-align:center}
    .table th{background:#f7fafc;font-size:12px;text-transform:uppercase;letter-spacing:.04em;position:sticky;top:0}
    .table input[type=number]{width:64px;padding:8px;border:1px solid var(--border);border-radius:10px;background:#fff}
    .table input[type=text]{width:100%;padding:8px;border:1px solid var(--border);border-radius:10px;background:#fff}
    .table .team{min-width:150px;text-align:left}
    .pill{display:inline-flex;align-items:center;gap:6px;border-radius:999px;padding:4px 8px;font-weight:700;font-size:12px}
    .pill-ok{background:#ecfdf5;color:#065f46}.pill-warn{background:#fff7ed;color:#9a3412}.pill-diff{background:#eef2ff;color:#3730a3}.pill-bad{background:#fef2f2;color:#991b1b}
    .stack{display:flex;flex-direction:column;gap:10px}
    .players{display:flex;gap:8px;flex-wrap:wrap}
    .player-btn{padding:8px 12px;border-radius:999px;border:1px solid var(--border);background:#fff;font-weight:700;cursor:pointer}
    .player-btn.active{background:var(--text);color:#fff;border-color:transparent}
    .space{height:8px}
    .match-head{display:flex;align-items:center;justify-content:space-between;gap:8px;flex-wrap:wrap}
    .match-title{font-weight:800}
    .seg{display:flex;gap:6px;align-items:center}
    .seg .btn{padding:6px 10px}
    .mini{font-size:12px;color:var(--muted)}
    @media(max-width:640px){
      h1{font-size:20px}
      .btn{padding:8px 10px;font-size:14px}
      .round-name,.cloud-box{padding:8px 10px}
      .table{min-width:520px}
      .table-wide{min-width:700px}
      .table input[type=number]{width:54px}
      .tab-btn{padding:8px 12px}
    }
  </style>
</head>
<body>
<div id="root" class="wrap"></div>
<script type="text/babel">
const {useState,useEffect,useMemo,useRef} = React;

// Firebase config (ваши данные)
const firebaseConfig = {
  apiKey: "AIzaSyAET0m2j5YyvXK9Gp4gxJbfZCqL6R42N8U",
  authDomain: "predict-8b1f4.firebaseapp.com",
  projectId: "predict-8b1f4",
  storageBucket: "predict-8b1f4.firebasestorage.app",
  messagingSenderId: "1086430765447",
  appId: "1:1086430765447:web:a85b5e8ff8392e55e93322"
};

firebase.initializeApp(firebaseConfig);
const db = firebase.firestore();
firebase.firestore().enablePersistence({synchronizeTabs:true}).catch(()=>{});

// Local keys
const STORAGE_KEYS = {
  round: 'fp_roundName',
  matches:'fp_matches',
  players:'fp_players',
  predictions:'fp_predictions',
  results:'fp_results',
  history:'fp_history',
  roomId:'fp_room_id',
};

function uid(){ return Math.random().toString(36).slice(2)+Date.now().toString(36); }
const DEVICE_ID_KEY = 'fp_device_id';
function getDeviceId(){
  try{
    let id = localStorage.getItem(DEVICE_ID_KEY);
    if(!id){ id = uid(); localStorage.setItem(DEVICE_ID_KEY, id); }
    return id;
  }catch{ return uid(); }
}
const DEVICE_ID = getDeviceId();

function getRoomFromQuery(){
  try{
    const p = new URLSearchParams(location.search);
    const r = (p.get('room')||'').trim();
    return r || null;
  }catch{ return null; }
}

function outcome(a,b){ if(a>b) return 1; if(a<b) return -1; return 0; }
function pointsFor(pred,res){
  if(pred==null || res==null) return 0;
  const {score1:ps1,score2:ps2} = pred||{};
  const {score1:rs1,score2:rs2} = res||{};
  if(ps1==null || ps2==null || rs1==null || rs2==null) return 0;
  if(ps1===rs1 && ps2===rs2) return 3;
  const sameOutcome = outcome(ps1,ps2)===outcome(rs1,rs2);
  const sameDiff = (ps1-ps2)===(rs1-rs2);
  if(sameDiff && sameOutcome) return 2;
  if(sameOutcome) return 1;
  return 0;
}

function usePersistentState(key, initial){
  const [state,setState] = useState(()=>{
    try{
      const raw = localStorage.getItem(key);
      return raw ? JSON.parse(raw) : initial;
    }catch{ return initial; }
  });
  useEffect(()=>{ try{ localStorage.setItem(key, JSON.stringify(state)); }catch{} },[key,state]);
  return [state,setState];
}

function App(){
  // Local state
  const [roundName,setRoundName] = usePersistentState(STORAGE_KEYS.round, 'Тур #1');
  const [matches,setMatches] = usePersistentState(STORAGE_KEYS.matches, []);
  const [players,setPlayers] = usePersistentState(STORAGE_KEYS.players, ['Виталий','Сергей','Грок']);
  const [currentPlayer,setCurrentPlayer] = useState(()=> players[0] || '');
  const [predictions,setPredictions] = usePersistentState(STORAGE_KEYS.predictions, {});
  const [results,setResults] = usePersistentState(STORAGE_KEYS.results, {});
  const [history,setHistory] = usePersistentState(STORAGE_KEYS.history, []);
  const [roomId,setRoomId] = usePersistentState(STORAGE_KEYS.roomId, getRoomFromQuery() || 'default');

  // Match-tab state
  const [currentMatchIdx,setCurrentMatchIdx] = useState(0);

  // Stabilization
  const isApplyingRemoteRef = useRef(false);
  const lastRemoteAtRef = useRef(null);
  const unsubRef = useRef(null);
  const hasInitialSyncRef = useRef(false);

  const focusedFieldRef = useRef(null);
  const pendingRemoteRef = useRef(null);
  const lastLocalEditAtRef = useRef(0);
  const AUTOSAVE_DELAY_MS = 2000;
  const EDIT_GRACE_MS = 1200;

  const markEdited = ()=>{ lastLocalEditAtRef.current = Date.now(); };

  useEffect(()=>{
    const r = getRoomFromQuery();
    if(r && r!==roomId) setRoomId(r);
  },[]);

  useEffect(()=> { if(!players.includes(currentPlayer)) setCurrentPlayer(players[0] || ''); },[players]);
  useEffect(()=> {
    if (matches.length === 0) { setCurrentMatchIdx(0); return; }
    if (currentMatchIdx < 0 || currentMatchIdx >= matches.length) setCurrentMatchIdx(0);
  }, [matches.length]);

  // Local CRUD
  function addBlankMatch(){ markEdited(); setMatches(prev => [...prev, { id: uid(), team1:'', team2:'' }]); }
  function addBatch(n=5){
    markEdited();
    setMatches(prev=>{
      const list=[...prev];
      for(let i=0;i<n;i++) list.push({id:uid(),team1:'',team2:''});
      return list;
    });
  }
  function updateMatch(id, field, value){
    markEdited();
    setMatches(prev => prev.map(m => m.id===id ? {...m, [field]: value} : m));
  }
  function deleteMatch(id){
    if(!confirm('Удалить матч?')) return;
    markEdited();
    setMatches(prev => prev.filter(m => m.id!==id));
    setPredictions(prev => { const copy = {...prev}; delete copy[id]; return copy; });
    setResults(prev => { const copy = {...prev}; delete copy[id]; return copy; });
  }
  function clearAll(){
    if(!confirm('Очистить все матчи, прогнозы и результаты текущего тура?')) return;
    markEdited();
    setMatches([]); setPredictions({}); setResults({});
  }
  function setPred(matchId, player, score1, score2){
    markEdited();
    setPredictions(prev=>{
      const m = prev[matchId] ? {...prev[matchId]} : {};
      m[player] = { score1, score2 };
      return { ...prev, [matchId]: m };
    });
  }
  function setRes(matchId, score1, score2){
    markEdited();
    setResults(prev=> ({ ...prev, [matchId]: { score1, score2 } }));
  }
  function copyFromPlayer(source){
    if(!source || source===currentPlayer) return;
    markEdited();
    setPredictions(prev=>{
      const copy = {...prev};
      matches.forEach(m=>{
        const src = copy[m.id]?.[source];
        if(src){
          const perMatch = copy[m.id] ? {...copy[m.id]} : {};
          perMatch[currentPlayer] = { ...src };
          copy[m.id] = perMatch;
        }
      });
      return copy;
    });
  }
  function fillDefault(s1,s2){
    markEdited();
    setPredictions(prev=>{
      const copy = {...prev};
      matches.forEach(m=>{
        const perMatch = copy[m.id] ? {...copy[m.id]} : {};
        perMatch[currentPlayer] = { score1:s1, score2:s2 };
        copy[m.id]=perMatch;
      });
      return copy;
    });
  }
  function clearPredictionsFor(playerName = currentPlayer){
    if(!playerName) return;
    markEdited();
    setPredictions(prev=>{
      const copy = {...prev};
      matches.forEach(m=>{
        if(copy[m.id]){
          const perMatch = {...copy[m.id]};
          delete perMatch[playerName];
          copy[m.id] = perMatch;
        }
      });
      return copy;
    });
  }
  function clearResults(){ if(!confirm('Очистить все результаты текущего тура?')) return; markEdited(); setResults({}); }

  // Players
  function addPlayer(name){
    const n = (name || '').trim();
    if(!n) return;
    if(players.includes(n)){ alert('Такой игрок уже есть'); return; }
    markEdited();
    setPlayers(prev => [...prev, n]);
  }
  function removePlayer(name){
    if(!confirm(`Удалить игрока "${name}"?`)) return;
    markEdited();
    setPlayers(prev => prev.filter(p => p!==name));
    setPredictions(prev=>{
      const copy = {...prev};
      Object.keys(copy).forEach(mid=>{
        const per = { ...(copy[mid]||{}) };
        delete per[name];
        copy[mid]=per;
      });
      return copy;
    });
  }

  // Points
  const currentPoints = useMemo(()=>{
    const score = Object.fromEntries(players.map(p=>[p,0]));
    matches.forEach(m=>{
      const res = results[m.id];
      players.forEach(p=>{
        const pred = predictions[m.id]?.[p];
        score[p] += pointsFor(pred,res);
      });
    });
    return score;
  },[players,matches,results,predictions]);

  const totalPoints = useMemo(()=>{
    const score = Object.fromEntries(players.map(p=>[p,0]));
    history.forEach(round=>{
      const playedPlayers = Object.keys(round.points || {});
      playedPlayers.forEach(p=>{
        if(score[p]==null) score[p]=0;
        score[p]+= round.points[p] || 0;
      });
    });
    return score;
  },[history,players]);

  function finalizeRound(){
    if(matches.length===0){ alert('Нет матчей в туре'); return; }
    const hasAnyResult = matches.some(m => results[m.id] && Number.isInteger(results[m.id].score1) && Number.isInteger(results[m.id].score2));
    if(!hasAnyResult){ alert('Сначала введите результаты матчей'); return; }

    const points = Object.fromEntries(players.map(p=>[p,0]));
    matches.forEach(m=>{
      const res = results[m.id];
      players.forEach(p=>{
        const pred = predictions[m.id]?.[p];
        points[p]+= pointsFor(pred,res);
      });
    });

    const round = {
      id: uid(),
      roundName: roundName || `Тур от ${new Date().toLocaleDateString()}`,
      date: new Date().toISOString(),
      matches: matches.map(m=>({ ...m })),
      results: JSON.parse(JSON.stringify(results)),
      predictions: JSON.parse(JSON.stringify(predictions)),
      points
    };
    markEdited();
    setHistory(prev=> [round, ...prev]);
    setMatches([]); setPredictions({}); setResults({});
    const next = roundName.replace(/#(\d+)/, (_,n)=>`#${Number(n)+1}`);
    setRoundName(next===roundName ? `${roundName} (след.)` : next);
    alert('Тур зафиксирован и перенесён в историю!');
  }

  function deleteHistoryRound(roundId){
    if(!confirm('Удалить запись истории тура?')) return;
    markEdited();
    setHistory(prev => prev.filter(r => r.id!==roundId));
  }

  // Build / Apply (safe merge)
  function buildData(){ return { roundName, matches, players, predictions, results, history }; }
  function buildDataWithMeta(){
    const data = buildData();
    return { ...data, _updatedAt: new Date().toISOString(), _updatedBy: DEVICE_ID };
  }

  // ВАЖНО: безопасное применение удалённых данных (не затирает свежий локальный ввод)
  function applyRemoteData(remote){
    const remoteAt = Date.parse(remote?._updatedAt || '') || 0;
    const lastLocal = lastLocalEditAtRef.current || 0;
    const preferLocal = remoteAt && lastLocal && remoteAt <= lastLocal + 1000;

    // matches
    const mergedMatches = (()=> {
      const byId = new Map();
      (remote.matches||[]).forEach(m=> byId.set(m.id, m));
      if (preferLocal) (matches||[]).forEach(m=> { if(!byId.has(m.id)) byId.set(m.id, m); });
      return Array.from(byId.values());
    })();

    // players
    const mergedPlayers = (()=> {
      if (!preferLocal) return remote.players ?? players;
      const set = new Set([...(players||[]), ...((remote.players)||[])]);
      return Array.from(set);
    })();

    // results
    const mergedResults = (()=> {
      const out = preferLocal ? {...results} : {};
      Object.entries(remote.results||{}).forEach(([mid, r])=>{
        const l = results[mid];
        if (preferLocal) {
          const l1 = Number.isInteger(l?.score1), l2 = Number.isInteger(l?.score2);
          const r1 = Number.isInteger(r?.score1), r2 = Number.isInteger(r?.score2);
          out[mid] = { score1: r1 ? r.score1 : (l1 ? l.score1 : null),
                       score2: r2 ? r.score2 : (l2 ? l.score2 : null) };
        } else {
          out[mid] = r;
        }
      });
      return out;
    })();

    // predictions
    const mergedPredictions = (()=> {
      const out = preferLocal ? JSON.parse(JSON.stringify(predictions)) : {};
      Object.entries(remote.predictions||{}).forEach(([mid, per])=>{
        out[mid] = out[mid] || {};
        Object.entries(per).forEach(([player, pr])=>{
          if (preferLocal) {
            const lp = out[mid][player];
            const l1 = Number.isInteger(lp?.score1), l2 = Number.isInteger(lp?.score2);
            const r1 = Number.isInteger(pr?.score1), r2 = Number.isInteger(pr?.score2);
            out[mid][player] = { score1: r1 ? pr.score1 : (l1 ? lp.score1 : null),
                                 score2: r2 ? pr.score2 : (l2 ? lp.score2 : null) };
          } else {
            out[mid][player] = pr;
          }
        });
      });
      return out;
    })();

    setRoundName(preferLocal ? roundName : (remote.roundName ?? roundName));
    setMatches(mergedMatches);
    setPlayers(mergedPlayers);
    setPredictions(mergedPredictions);
    setResults(mergedResults);
    setHistory(remote.history ?? history);
  }

  // Firestore realtime
  useEffect(()=>{
    if (unsubRef.current) { unsubRef.current(); unsubRef.current = null; }
    hasInitialSyncRef.current = false;

    const rid = (roomId || 'default').trim();
    if(!rid) return;

    const ref = db.collection('rooms').doc(rid);

    unsubRef.current = ref.onSnapshot(async (snap)=>{
      const exists = snap.exists;
      const editingNow = focusedFieldRef.current != null || (Date.now() - lastLocalEditAtRef.current) < EDIT_GRACE_MS;

      if(!hasInitialSyncRef.current){
        hasInitialSyncRef.current = true;
        if(exists){
          const remote = snap.data() || {};
          if(editingNow){
            pendingRemoteRef.current = remote;
          }else{
            isApplyingRemoteRef.current = true;
            applyRemoteData(remote);
            lastRemoteAtRef.current = remote?._updatedAt || null;
            isApplyingRemoteRef.current = false;
          }
        } else {
          try{ await ref.set(buildDataWithMeta()); }catch(e){ console.warn('init set error', e); }
        }
        return;
      }

      if(exists){
        const remote = snap.data() || {};
        const remoteAt = remote?._updatedAt || null;
        if(remoteAt && remoteAt !== lastRemoteAtRef.current){
          if(remote._updatedBy !== DEVICE_ID){
            if(editingNow){
              pendingRemoteRef.current = remote;
            }else{
              isApplyingRemoteRef.current = true;
              applyRemoteData(remote);
              lastRemoteAtRef.current = remoteAt;
              isApplyingRemoteRef.current = false;
            }
          }else{
            lastRemoteAtRef.current = remoteAt;
          }
        }
      }
    });

    return ()=>{ if (unsubRef.current) { unsubRef.current(); unsubRef.current = null; } };
  },[roomId]);

  // Autosave (debounce ~2s), не сохраняем пока печатают
  useEffect(()=>{
    if(!hasInitialSyncRef.current) return;
    if(isApplyingRemoteRef.current) return;

    const editingNow = focusedFieldRef.current != null || (Date.now() - lastLocalEditAtRef.current) < EDIT_GRACE_MS;
    if(editingNow) return;

    const handle = setTimeout(async ()=>{
      try{
        const rid = (roomId || 'default').trim();
        if(!rid) return;
        await db.collection('rooms').doc(rid).set(buildDataWithMeta(), {merge:true});
      }catch(e){ console.warn('autosave error', e); }
    }, AUTOSAVE_DELAY_MS);

    return ()=> clearTimeout(handle);
  }, [roundName, matches, players, predictions, results, history, roomId]);

  // После blur применяем отложенные удалённые данные
  function handleBlur(){
    focusedFieldRef.current = null;
    setTimeout(()=>{
      if(pendingRemoteRef.current){
        const remote = pendingRemoteRef.current;
        pendingRemoteRef.current = null;
        isApplyingRemoteRef.current = true;
        applyRemoteData(remote);
        lastRemoteAtRef.current = remote?._updatedAt || null;
        isApplyingRemoteRef.current = false;
      }
    }, 50);
  }

  // Helpers for match view
  const currentMatch = matches[currentMatchIdx] || null;
  const currentMatchRes = currentMatch ? results[currentMatch.id] : null;
  const outcomeStats = useMemo(()=>{
    if(!currentMatch) return {home:0,draw:0,away:0,filled:0};
    let home=0,draw=0,away=0,filled=0;
    players.forEach(p=>{
      const pr = predictions[currentMatch.id]?.[p];
      if(pr && Number.isInteger(pr.score1) && Number.isInteger(pr.score2)){
        filled++;
        const o = outcome(pr.score1, pr.score2);
        if(o>0) home++; else if(o<0) away++; else draw++;
      }
    });
    return {home,draw,away,filled};
  },[players,predictions,currentMatchIdx,matches,results]);

  function gotoPrevMatch(){
    if(matches.length===0) return;
    setCurrentMatchIdx(i=> (i-1+matches.length)%matches.length);
  }
  function gotoNextMatch(){
    if(matches.length===0) return;
    setCurrentMatchIdx(i=> (i+1)%matches.length);
  }

  // UI
  const [tab,setTab] = useState('setup');

  function shareLink(){
    const url = new URL(location.href);
    url.searchParams.set('room', roomId || 'default');
    navigator.clipboard.writeText(url.toString()).then(()=>{
      alert('Ссылка скопирована. Откройте её на других устройствах.');
    }).catch(()=>{
      prompt('Скопируйте ссылку:', url.toString());
    });
  }

  return (
    <>
      <header>
        <h1>Прогнозы на футбол</h1>
        <div className="toolbar">
          <div className="round-name">
            <strong>Тур:</strong>
            <input
              value={roundName}
              onChange={e=>{ setRoundName(e.target.value); markEdited(); }}
              onFocus={()=>{ focusedFieldRef.current='roundName'; }}
              onBlur={handleBlur}
              placeholder="Название тура"
            />
          </div>

          <div className="cloud-box">
            <strong>Комната:</strong>
            <input
              value={roomId}
              onChange={e=>{ setRoomId(e.target.value.trim()); markEdited(); }}
              onFocus={()=>{ focusedFieldRef.current='roomId'; }}
              onBlur={handleBlur}
              placeholder="например, liga"
            />
            <button className="btn btn-ghost" onClick={shareLink}>Ссылка</button>
          </div>
        </div>
      </header>

      <nav className="tabs">
        {[
          ['setup','Матчи'],
          ['predictions','Прогнозы'],
          ['match','Матч'],
          ['results','Результаты'],
          ['scores','Очки'],
          ['history','История'],
        ].map(([id,label])=>(
          <button key={id} className={`tab-btn ${tab===id?'active':''}`} onClick={()=>setTab(id)}>{label}</button>
        ))}
      </nav>

      {tab==='setup' && (
        <div className="grid grid-2">
          <div className="card">
            <h2>Список матчей</h2>
            <div className="row">
              <button className="btn btn-primary" onClick={addBlankMatch}>+ Матч</button>
              <button className="btn btn-ghost" onClick={()=>addBatch(5)}>+5</button>
              <button className="btn btn-ghost" onClick={()=>addBatch(10)}>+10</button>
              <button className="btn btn-danger" onClick={clearAll}>Очистить тур</button>
            </div>
            <div className="table-wrap">
              <table className="table">
                <thead>
                <tr>
                  <th>#</th><th className="team">Команда 1</th><th className="team">Команда 2</th><th>Действия</th>
                </tr>
                </thead>
                <tbody>
                {matches.length===0 ? (
                  <tr><td colSpan="4" className="muted">Добавьте матчи</td></tr>
                ) : matches.map((m,idx)=>(
                  <tr key={m.id}>
                    <td>{idx+1}</td>
                    <td className="team">
                      <input type="text"
                        value={m.team1}
                        onChange={e=>updateMatch(m.id,'team1',e.target.value)}
                        onFocus={()=>{ focusedFieldRef.current=`m:${m.id}:team1`; }}
                        onBlur={handleBlur}
                        placeholder="Команда 1"/>
                    </td>
                    <td className="team">
                      <input type="text"
                        value={m.team2}
                        onChange={e=>updateMatch(m.id,'team2',e.target.value)}
                        onFocus={()=>{ focusedFieldRef.current=`m:${m.id}:team2`; }}
                        onBlur={handleBlur}
                        placeholder="Команда 2"/>
                    </td>
                    <td><button className="btn btn-ghost" onClick={()=>deleteMatch(m.id)}>Удалить</button></td>
                  </tr>
                ))}
                </tbody>
              </table>
            </div>
            <div className="space"></div>
            <div className="muted">На узких экранах таблица прокручивается горизонтально.</div>
          </div>

          <div className="card">
            <h2>Игроки</h2>
            <PlayersManager players={players} addPlayer={addPlayer} removePlayer={removePlayer}/>
            <div className="space"></div>
            <h2>Сводка</h2>
            <div className="stack">
              <div className="chip">Матчей: <strong>{matches.length}</strong></div>
              <div className="chip">Игроков: <strong>{players.length}</strong></div>
              <div className="chip">Есть результаты: <strong>{Object.keys(results).filter(k=>Number.isInteger(results[k]?.score1)).length}</strong></div>
            </div>
          </div>
        </div>
      )}

      {tab==='predictions' && (
        <div className="card">
          <h2>Прогнозы</h2>
          <div className="row" style={{justifyContent:'space-between',alignItems:'flex-start'}}>
            <div className="stack" style={{flex:1}}>
              <div className="players">
                {players.map(p=>(
                  <button key={p} className={`player-btn ${currentPlayer===p?'active':''}`} onClick={()=>setCurrentPlayer(p)}>{p}</button>
                ))}
              </div>
              <div className="row">
                <CopyPredictions players={players} currentPlayer={currentPlayer} onCopy={copyFromPlayer}/>
                <button className="btn btn-ghost" onClick={()=>fillDefault(1,1)}>Всем 1:1</button>
                <button className="btn btn-ghost" onClick={()=>fillDefault(0,0)}>Всем 0:0</button>
                <button className="btn btn-danger" onClick={()=>clearPredictionsFor()}>Очистить прогнозы игрока</button>
              </div>
            </div>
            <div className="stack" style={{minWidth:220}}>
              <div className="chip">Текущие очки: <strong>{currentPoints[currentPlayer] ?? 0}</strong></div>
              <div className="chip">Итого (история): <strong>{totalPoints[currentPlayer] ?? 0}</strong></div>
            </div>
          </div>

          <div className="table-wrap">
            <table className="table table-wide">
              <thead>
              <tr>
                <th>#</th><th className="team">Матч</th><th>Прогноз {currentPlayer}</th><th>Результат</th><th>Очки</th>
              </tr>
              </thead>
              <tbody>
              {matches.length===0 ? (
                <tr><td colSpan="5" className="muted">Нет матчей. Добавьте их во вкладке «Матчи».</td></tr>
              ) : matches.map((m,idx)=>{
                const pred = predictions[m.id]?.[currentPlayer] || {};
                const res = results[m.id];
                const pts = pointsFor(pred,res);
                return (
                  <tr key={m.id}>
                    <td>{idx+1}</td>
                    <td className="team"><strong>{m.team1||'—'}</strong> vs <strong>{m.team2||'—'}</strong></td>
                    <td>
                      <div className="row" style={{justifyContent:'center'}}>
                        <input type="number" min="0"
                          value={Number.isInteger(pred.score1)?pred.score1:''}
                          onChange={e=>setPred(m.id,currentPlayer, parseIntSafe(e.target.value), pred.score2)}
                          onFocus={()=>{ focusedFieldRef.current=`pred:${m.id}:p1`; }}
                          onBlur={handleBlur}
                        />
                        <span>:</span>
                        <input type="number" min="0"
                          value={Number.isInteger(pred.score2)?pred.score2:''}
                          onChange={e=>setPred(m.id,currentPlayer, pred.score1, parseIntSafe(e.target.value))}
                          onFocus={()=>{ focusedFieldRef.current=`pred:${m.id}:p2`; }}
                          onBlur={handleBlur}
                        />
                      </div>
                    </td>
                    <td>
                      <span className="muted">{Number.isInteger(res?.score1)?res.score1:'—'}:{Number.isInteger(res?.score2)?res.score2:'—'}</span>
                    </td>
                    <td>
                      {pts===3 && <span className="pill pill-ok">3</span>}
                      {pts===2 && <span className="pill pill-diff">2</span>}
                      {pts===1 && <span className="pill pill-warn">1</span>}
                      {pts===0 && <span className="pill pill-bad">0</span>}
                    </td>
                  </tr>
                );
              })}
              </tbody>
            </table>
          </div>
        </div>
      )}

      {tab==='match' && (
        <div className="card">
          <div className="match-head">
            <div className="seg">
              <button className="btn btn-ghost" onClick={gotoPrevMatch} disabled={matches.length===0}>←</button>
              <button className="btn btn-ghost" onClick={gotoNextMatch} disabled={matches.length===0}>→</button>
              <select
                value={String(currentMatchIdx)}
                onChange={e=>setCurrentMatchIdx(Math.max(0,Math.min(matches.length-1,parseInt(e.target.value)||0)))}
              >
                {matches.map((m,idx)=>(
                  <option key={m.id} value={idx}>{`#${idx+1} — ${m.team1||'—'} vs ${m.team2||'—'}`}</option>
                ))}
              </select>
            </div>
            <div className="match-title">
              {currentMatch ? (<>
                <strong>{currentMatch.team1||'—'}</strong> vs <strong>{currentMatch.team2||'—'}</strong>
              </>) : 'Нет матчей'}
            </div>
            <div className="seg mini">
              <span className="chip">Исходы: Дома {outcomeStats.home}</span>
              <span className="chip">Ничья {outcomeStats.draw}</span>
              <span className="chip">Гости {outcomeStats.away}</span>
            </div>
          </div>

          {!currentMatch ? (
            <div className="muted" style={{marginTop:8}}>Добавьте матчи во вкладке «Матчи».</div>
          ):(
            <>
              <div className="row" style={{marginTop:8, justifyContent:'space-between', alignItems:'center'}}>
                <div className="chip">Прогнозов заполнено: <strong>{outcomeStats.filled}/{players.length}</strong></div>
                <div className="row">
                  <span className="muted">Результат:</span>
                  <input type="number" min="0"
                    value={Number.isInteger(currentMatchRes?.score1)?currentMatchRes.score1:''}
                    onChange={e=>setRes(currentMatch.id, parseIntSafe(e.target.value), currentMatchRes?.score2)}
                    onFocus={()=>{ focusedFieldRef.current=`mres:${currentMatch.id}:r1`; }}
                    onBlur={handleBlur}
                  />
                  <span>:</span>
                  <input type="number" min="0"
                    value={Number.isInteger(currentMatchRes?.score2)?currentMatchRes.score2:''}
                    onChange={e=>setRes(currentMatch.id, currentMatchRes?.score1, parseIntSafe(e.target.value))}
                    onFocus={()=>{ focusedFieldRef.current=`mres:${currentMatch.id}:r2`; }}
                    onBlur={handleBlur}
                  />
                </div>
              </div>

              <div className="table-wrap">
                <table className="table">
                  <thead>
                  <tr>
                    <th>Игрок</th>
                    <th>Прогноз</th>
                    <th>Очки</th>
                  </tr>
                  </thead>
                  <tbody>
                  {players.map(p=>{
                    const pr = predictions[currentMatch.id]?.[p] || {};
                    const pts = pointsFor(pr, currentMatchRes);
                    return (
                      <tr key={p}>
                        <td style={{textAlign:'left'}}><strong>{p}</strong></td>
                        <td>
                          <div className="row" style={{justifyContent:'center'}}>
                            <input type="number" min="0"
                              value={Number.isInteger(pr.score1)?pr.score1:''}
                              onChange={e=>setPred(currentMatch.id, p, parseIntSafe(e.target.value), pr.score2)}
                              onFocus={()=>{ focusedFieldRef.current=`mpred:${currentMatch.id}:${p}:p1`; }}
                              onBlur={handleBlur}
                            />
                            <span>:</span>
                            <input type="number" min="0"
                              value={Number.isInteger(pr.score2)?pr.score2:''}
                              onChange={e=>setPred(currentMatch.id, p, pr.score1, parseIntSafe(e.target.value))}
                              onFocus={()=>{ focusedFieldRef.current=`mpred:${currentMatch.id}:${p}:p2`; }}
                              onBlur={handleBlur}
                            />
                          </div>
                        </td>
                        <td>
                          {pts===3 && <span className="pill pill-ok">3</span>}
                          {pts===2 && <span className="pill pill-diff">2</span>}
                          {pts===1 && <span className="pill pill-warn">1</span>}
                          {(pts===0 || pts==null) && <span className="pill pill-bad">0</span>}
                        </td>
                      </tr>
                    );
                  })}
                  </tbody>
                </table>
              </div>
            </>
          )}
        </div>
      )}

      {tab==='results' && (
        <div className="card">
          <h2>Результаты</h2>
          <div className="row">
            <button className="btn btn-ok" onClick={finalizeRound}>Финализировать тур в историю</button>
            <button className="btn btn-danger" onClick={clearResults}>Очистить результаты</button>
          </div>
          <div className="table-wrap">
            <table className="table table-wide">
              <thead>
              <tr>
                <th>#</th><th className="team">Матч</th><th>Результат</th><th>Кто угадал</th>
              </tr>
              </thead>
              <tbody>
              {matches.length===0 ? (
                <tr><td colSpan="4" className="muted">Нет матчей</td></tr>
              ) : matches.map((m,idx)=>{
                const res = results[m.id] || {};
                const exact = players.filter(p=>{
                  const pred = predictions[m.id]?.[p];
                  return pointsFor(pred,res)===3;
                });
                return (
                  <tr key={m.id}>
                    <td>{idx+1}</td>
                    <td className="team"><strong>{m.team1||'—'}</strong> vs <strong>{m.team2||'—'}</strong></td>
                    <td>
                      <div className="row" style={{justifyContent:'center'}}>
                        <input type="number" min="0"
                          value={Number.isInteger(res.score1)?res.score1:''}
                          onChange={e=>setRes(m.id, parseIntSafe(e.target.value), res.score2)}
                          onFocus={()=>{ focusedFieldRef.current=`res:${m.id}:r1`; }}
                          onBlur={handleBlur}
                        />
                        <span>:</span>
                        <input type="number" min="0"
                          value={Number.isInteger(res.score2)?res.score2:''}
                          onChange={e=>setRes(m.id, res.score1, parseIntSafe(e.target.value))}
                          onFocus={()=>{ focusedFieldRef.current=`res:${m.id}:r2`; }}
                          onBlur={handleBlur}
                        />
                      </div>
                    </td>
                    <td>
                      {exact.length>0 ? exact.join(', ') : <span className="muted">—</span>}
                    </td>
                  </tr>
                );
              })}
              </tbody>
            </table>
          </div>
          <div className="space"></div>
          <div className="muted">На телефоне просто прокрутите таблицу по горизонтали.</div>
        </div>
      )}

      {tab==='scores' && (
        <div className="grid">
          <div className="card">
            <h2>Очки за текущий тур</h2>
            <div className="table-wrap">
              <table className="table">
                <thead><tr><th>Игрок</th><th>Очки</th></tr></thead>
                <tbody>
                {players.map(p=>(
                  <tr key={p}><td>{p}</td><td><strong>{currentPoints[p] ?? 0}</strong></td></tr>
                ))}
                </tbody>
              </table>
            </div>
          </div>
          <div className="card">
            <h2>Общий счёт (история)</h2>
            <div className="table-wrap">
              <table className="table">
                <thead><tr><th>Игрок</th><th>Очки</th></tr></thead>
                <tbody>
                {players.map(p=>(
                  <tr key={p}><td>{p}</td><td><strong>{totalPoints[p] ?? 0}</strong></td></tr>
                ))}
                </tbody>
              </table>
            </div>
          </div>
        </div>
      )}

      {tab==='history' && (
        <div className="card">
          <h2>История туров</h2>
          {history.length===0 ? (
            <div className="muted">История пуста</div>
          ):(
            <div className="stack">
              {history.map(round=>(
                <div key={round.id} className="card" style={{padding:'12px'}}>
                  <div className="row" style={{justifyContent:'space-between',alignItems:'center'}}>
                    <div className="row" style={{gap:12,alignItems:'baseline',flexWrap:'wrap'}}>
                      <strong>{round.roundName}</strong>
                      <span className="muted">{new Date(round.date).toLocaleString()}</span>
                      <span className="chip">Матчей: {round.matches.length}</span>
                    </div>
                    <button className="btn btn-ghost" onClick={()=>deleteHistoryRound(round.id)}>Удалить</button>
                  </div>
                  <div className="space"></div>
                  <div className="table-wrap">
                    <table className="table table-wide">
                      <thead><tr><th>#</th><th className="team">Матч</th><th>Результат</th><th>Очки по игрокам</th></tr></thead>
                      <tbody>
                      {round.matches.map((m,idx)=>{
                        const res = round.results[m.id];
                        return (
                          <tr key={m.id}>
                            <td>{idx+1}</td>
                            <td className="team"><strong>{m.team1||'—'}</strong> vs <strong>{m.team2||'—'}</strong></td>
                            <td>{Number.isInteger(res?.score1)?res.score1:'—'}:{Number.isInteger(res?.score2)?res.score2:'—'}</td>
                            <td style={{textAlign:'left'}}>
                              <div className="row" style={{flexWrap:'wrap',gap:6,justifyContent:'flex-start'}}>
                                {players.map(p=>{
                                  const pred = round.predictions[m.id]?.[p];
                                  const pts = pointsFor(pred,res);
                                  return <span key={p} className="chip">{p}: <strong>{pts}</strong></span>
                                })}
                              </div>
                            </td>
                          </tr>
                        );
                      })}
                      </tbody>
                    </table>
                  </div>
                  <div className="space"></div>
                  <div className="row" style={{flexWrap:'wrap',gap:8}}>
                    {players.map(p=>(
                      <span key={p} className="chip">{p}: <strong>{round.points[p] ?? 0}</strong></span>
                    ))}
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>
      )}
    </>
  );
}

function parseIntSafe(v){
  if(v==='' || v==null) return null;
  const n = Number(v);
  return Number.isFinite(n) && n>=0 ? Math.floor(n) : null;
}

function PlayersManager({players,addPlayer,removePlayer}){
  const [name,setName] = React.useState('');
  return (
    <div className="stack">
      <div className="row">
        <input className="table" style={{ width: 220 }} type="text" placeholder="Новый игрок"
               value={name}
               onChange={e=>setName(e.target.value)}
        />
        <button className="btn btn-primary" onClick={()=>{ addPlayer(name); setName(''); }}>Добавить</button>
      </div>
      <div className="players">
        {players.map(p=>(
          <span key={p} className="chip">{p} <button className="btn btn-ghost" onClick={()=>removePlayer(p)}>×</button></span>
        ))}
      </div>
      <div className="muted">Удаление игрока очищает его прогнозы в текущем туре.</div>
    </div>
  );
}

function CopyPredictions({players,currentPlayer,onCopy}){
  const [src,setSrc] = React.useState('');
  React.useEffect(()=>{ setSrc(''); },[currentPlayer]);
  return (
    <div className="row">
      <select className="table" style={{ width: 180 }}
              value={src} onChange={e=>setSrc(e.target.value)}>
        <option value="">Копировать из...</option>
        {players.filter(p=>p!==currentPlayer).map(p=>(
          <option key={p} value={p}>{p}</option>
        ))}
      </select>
      <button className="btn btn-ghost" disabled={!src} onClick={()=>onCopy(src)}>Копировать</button>
    </div>
  );
}

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App/>);
</script>
</body>
</html>
