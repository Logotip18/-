<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Прогнозы на футбол — Тур</title>
  <script src="https://unpkg.com/react@18.2.0/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone@7.22.9/babel.min.js"></script>
  <style>
    :root{
      --bg:#f5f7fb;
      --card:#fff;
      --text:#222;
      --muted:#667084;
      --brand:#0d6efd;
      --brand-2:#00bcd4;
      --ok:#19a974;
      --warn:#ff9800;
      --danger:#ef4444;
      --border:#e5e7eb;
      --shadow:0 6px 18px rgba(0,0,0,.06);
      --radius:14px;
      --radius-sm:10px;
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif;
      background:linear-gradient(135deg,#e8f0ff,#f8fbff 40%,#eefaf7); color:var(--text);
    }
    .wrap{max-width:1100px;margin:0 auto;padding:20px 16px 60px}
    header{display:flex;align-items:center;justify-content:space-between;gap:16px;margin:10px 0 20px}
    h1{margin:0;font-size:24px;font-weight:800;letter-spacing:.2px;background:linear-gradient(45deg,var(--brand),var(--brand-2));-webkit-background-clip:text;-webkit-text-fill-color:transparent}
    .toolbar{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    .round-name{display:flex;gap:8px;align-items:center;background:var(--card);border:1px solid var(--border);border-radius:999px;padding:8px 12px;box-shadow:var(--shadow)}
    .round-name input{border:none;outline:none;font-size:14px;background:transparent;min-width:200px}
    .tabs{display:flex;gap:8px;flex-wrap:wrap;margin:0 0 14px}
    .tab-btn{border:1px solid var(--border);background:var(--card);padding:10px 14px;border-radius:999px;cursor:pointer;font-weight:600;color:var(--muted)}
    .tab-btn.active{background:linear-gradient(45deg,var(--brand),var(--brand-2));color:#fff;border-color:transparent;box-shadow:var(--shadow)}
    .grid{display:grid;gap:16px}
    @media(min-width:900px){.grid-2{grid-template-columns:1.15fr .85fr}}
    .card{background:var(--card);border:1px solid var(--border);border-radius:var(--radius);box-shadow:var(--shadow);padding:14px}
    .card h2{margin:0 0 10px;font-size:18px}
    .sub{color:var(--muted);font-size:13px}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .btn{border:none;border-radius:10px;padding:10px 14px;font-weight:700;cursor:pointer;display:inline-flex;gap:8px;align-items:center}
    .btn:disabled{opacity:.5;cursor:not-allowed}
    .btn-primary{background:linear-gradient(45deg,var(--brand),var(--brand-2));color:#fff;box-shadow:var(--shadow)}
    .btn-ghost{background:#fff;border:1px solid var(--border)}
    .btn-danger{background:linear-gradient(45deg,#ef5350,#ef4444);color:#fff}
    .btn-ok{background:linear-gradient(45deg,#22c55e,#16a34a);color:#fff}
    .chip{display:inline-flex;align-items:center;gap:6px;border:1px solid var(--border);border-radius:999px;padding:6px 10px;background:#fff;font-size:12px}
    .muted{color:var(--muted);font-size:12px}
    .table{width:100%;border-collapse:collapse;margin-top:4px}
    .table th,.table td{border-bottom:1px solid var(--border);padding:10px 8px;text-align:center}
    .table th{background:#f7fafc;font-size:12px;text-transform:uppercase;letter-spacing:.04em}
    .table input[type=number]{width:70px;padding:8px;border:1px solid var(--border);border-radius:10px;background:#fff}
    .table input[type=text]{width:100%;padding:8px;border:1px solid var(--border);border-radius:10px;background:#fff}
    .table .team{min-width:150px;text-align:left}
    .pill{display:inline-flex;align-items:center;gap:6px;border-radius:999px;padding:4px 8px;font-weight:700;font-size:12px}
    .pill-ok{background:#ecfdf5;color:#065f46}
    .pill-warn{background:#fff7ed;color:#9a3412}
    .pill-diff{background:#eef2ff;color:#3730a3}
    .pill-bad{background:#fef2f2;color:#991b1b}
    .stack{display:flex;flex-direction:column;gap:10px}
    .players{display:flex;gap:8px;flex-wrap:wrap}
    .player-btn{padding:8px 12px;border-radius:999px;border:1px solid var(--border);background:#fff;font-weight:700;cursor:pointer}
    .player-btn.active{background:var(--text);color:#fff;border-color:transparent}
    .helper{background:#fff;border:1px dashed var(--border);padding:8px 10px;border-radius:10px;color:var(--muted);font-size:12px}
    .textarea{width:100%;min-height:120px;border:1px solid var(--border);border-radius:12px;padding:10px;resize:vertical}
    .right{display:flex;justify-content:flex-end}
    .space{height:8px}
    .cloud-box{display:flex;gap:8px;align-items:center;background:var(--card);border:1px solid var(--border);border-radius:999px;padding:8px 12px;box-shadow:var(--shadow)}
    .cloud-box input{border:none;outline:none;font-size:14px;background:transparent;min-width:280px}
  </style>
</head>
<body>
<div id="root" class="wrap"></div>
<script type="text/babel">
const {useState,useEffect,useMemo,useRef} = React;

const STORAGE_KEYS = {
  round: 'fp_roundName',
  matches:'fp_matches',
  players:'fp_players',
  predictions:'fp_predictions',
  results:'fp_results',
  history:'fp_history',
  cloudUrl:'fp_cloud_url',
  autoSync:'fp_autoSync',
};

function uid(){ return Math.random().toString(36).slice(2)+Date.now().toString(36); }

const DEVICE_ID_KEY = 'fp_device_id';
function getDeviceId(){
  try{
    let id = localStorage.getItem(DEVICE_ID_KEY);
    if(!id){ id = uid(); localStorage.setItem(DEVICE_ID_KEY, id); }
    return id;
  }catch{ return uid(); }
}
const DEVICE_ID = getDeviceId();

function outcome(a,b){
  if(a>b) return 1;
  if(a<b) return -1;
  return 0;
}
function pointsFor(pred,res){
  if(pred==null || res==null) return 0;
  const {score1:ps1,score2:ps2} = pred||{};
  const {score1:rs1,score2:rs2} = res||{};
  if(ps1==null || ps2==null || rs1==null || rs2==null) return 0;
  if(ps1===rs1 && ps2===rs2) return 3;
  const sameOutcome = outcome(ps1,ps2)===outcome(rs1,rs2);
  const sameDiff = (ps1-ps2)===(rs1-rs2);
  if(sameDiff && sameOutcome) return 2;
  if(sameOutcome) return 1;
  return 0;
}

function usePersistentState(key, initial){
  const [state,setState] = useState(()=>{
    try{
      const raw = localStorage.getItem(key);
      return raw ? JSON.parse(raw) : initial;
    }catch{ return initial; }
  });
  useEffect(()=>{
    try{ localStorage.setItem(key, JSON.stringify(state)); }catch{}
  },[key,state]);
  return [state,setState];
}

function App(){
  const [roundName,setRoundName] = usePersistentState(STORAGE_KEYS.round, 'Тур #1');
  const [matches,setMatches] = usePersistentState(STORAGE_KEYS.matches, []);
  const [players,setPlayers] = usePersistentState(STORAGE_KEYS.players, ['Виталий','Сергей','Грок']);
  const [currentPlayer,setCurrentPlayer] = useState(()=> players[0] || '');
  const [predictions,setPredictions] = usePersistentState(STORAGE_KEYS.predictions, {}); // {matchId: {player: {score1,score2}}}
  const [results,setResults] = usePersistentState(STORAGE_KEYS.results, {}); // {matchId: {score1,score2}}
  const [history,setHistory] = usePersistentState(STORAGE_KEYS.history, []); // [{id,roundName,date,matches,results,predictions,points}]
  const [cloudUrl,setCloudUrl] = usePersistentState(STORAGE_KEYS.cloudUrl, '');
  const [autoSync,setAutoSync] = usePersistentState(STORAGE_KEYS.autoSync, true);

  const isApplyingRemoteRef = useRef(false);
  const lastRemoteAtRef = useRef(null);

  useEffect(()=> {
    if(!players.includes(currentPlayer)) setCurrentPlayer(players[0] || '');
  },[players]);

  function addBlankMatch(){
    const newMatch = { id: uid(), team1:'', team2:'' };
    setMatches(prev => [...prev, newMatch]);
  }
  function addBatch(n=5){
    setMatches(prev=>{
      const list=[...prev];
      for(let i=0;i<n;i++) list.push({id:uid(),team1:'',team2:''});
      return list;
    });
  }
  function updateMatch(id, field, value){
    setMatches(prev => prev.map(m => m.id===id ? {...m, [field]: value} : m));
  }
  function deleteMatch(id){
    if(!confirm('Удалить матч?')) return;
    setMatches(prev => prev.filter(m => m.id!==id));
    setPredictions(prev => {
      const copy = {...prev};
      delete copy[id];
      return copy;
    });
    setResults(prev => {
      const copy = {...prev};
      delete copy[id];
      return copy;
    });
  }
  function clearAll(){
    if(!confirm('Очистить все матчи, прогнозы и результаты текущего тура?')) return;
    setMatches([]); setPredictions({}); setResults({});
  }

  function setPred(matchId, player, score1, score2){
    setPredictions(prev=>{
      const m = prev[matchId] ? {...prev[matchId]} : {};
      m[player] = { score1, score2 };
      return { ...prev, [matchId]: m };
    });
  }
  function setRes(matchId, score1, score2){
    setResults(prev=> ({ ...prev, [matchId]: { score1, score2 } }));
  }

  function copyFromPlayer(source){
    if(!source || source===currentPlayer) return;
    setPredictions(prev=>{
      const copy = {...prev};
      matches.forEach(m=>{
        const src = copy[m.id]?.[source];
        if(src){
          const perMatch = copy[m.id] ? {...copy[m.id]} : {};
          perMatch[currentPlayer] = { ...src };
          copy[m.id] = perMatch;
        }
      });
      return copy;
    });
  }
  function fillDefault(s1,s2){
    setPredictions(prev=>{
      const copy = {...prev};
      matches.forEach(m=>{
        const perMatch = copy[m.id] ? {...copy[m.id]} : {};
        perMatch[currentPlayer] = { score1:s1, score2:s2 };
        copy[m.id]=perMatch;
      });
      return copy;
    });
  }
  function clearPredictionsFor(playerName = currentPlayer){
    if(!playerName) return;
    setPredictions(prev=>{
      const copy = {...prev};
      matches.forEach(m=>{
        if(copy[m.id]){
          const perMatch = {...copy[m.id]};
          delete perMatch[playerName];
          copy[m.id] = perMatch;
        }
      });
      return copy;
    });
  }
  function clearResults(){
    if(!confirm('Очистить все результаты текущего тура?')) return;
    setResults({});
  }

  const currentPoints = useMemo(()=>{
    const score = Object.fromEntries(players.map(p=>[p,0]));
    matches.forEach(m=>{
      const res = results[m.id];
      players.forEach(p=>{
        const pred = predictions[m.id]?.[p];
        score[p] += pointsFor(pred,res);
      });
    });
    return score;
  },[players,matches,results,predictions]);

  const totalPoints = useMemo(()=>{
    const score = Object.fromEntries(players.map(p=>[p,0]));
    history.forEach(round=>{
      const playedPlayers = Object.keys(round.points || {});
      playedPlayers.forEach(p=>{
        if(score[p]==null) score[p]=0;
        score[p]+= round.points[p] || 0;
      });
    });
    return score;
  },[history,players]);

  function finalizeRound(){
    if(matches.length===0){ alert('Нет матчей в туре'); return; }
    const hasAnyResult = matches.some(m => results[m.id] && Number.isInteger(results[m.id].score1) && Number.isInteger(results[m.id].score2));
    if(!hasAnyResult){ alert('Сначала введите результаты матчей'); return; }

    const points = Object.fromEntries(players.map(p=>[p,0]));
    matches.forEach(m=>{
      const res = results[m.id];
      players.forEach(p=>{
        const pred = predictions[m.id]?.[p];
        points[p]+= pointsFor(pred,res);
      });
    });

    const round = {
      id: uid(),
      roundName: roundName || `Тур от ${new Date().toLocaleDateString()}`,
      date: new Date().toISOString(),
      matches: matches.map(m=>({ ...m })),
      results: JSON.parse(JSON.stringify(results)),
      predictions: JSON.parse(JSON.stringify(predictions)),
      points
    };
    setHistory(prev=> [round, ...prev]);
    setMatches([]); setPredictions({}); setResults({});
    const next = roundName.replace(/#(\d+)/, (_,n)=>`#${Number(n)+1}`);
    setRoundName(next===roundName ? `${roundName} (след.)` : next);
    alert('Тур зафиксирован и перенесён в историю!');
  }

  function deleteHistoryRound(roundId){
    if(!confirm('Удалить запись истории тура?')) return;
    setHistory(prev => prev.filter(r => r.id!==roundId));
  }

  function addPlayer(name){
    const n = (name || '').trim();
    if(!n) return;
    if(players.includes(n)){ alert('Такой игрок уже есть'); return; }
    setPlayers(prev => [...prev, n]);
  }
  function removePlayer(name){
    if(!confirm(`Удалить игрока "${name}"?`)) return;
    setPlayers(prev => prev.filter(p => p!==name));
    setPredictions(prev=>{
      const copy = {...prev};
      Object.keys(copy).forEach(mid=>{
        const per = { ...(copy[mid]||{}) };
        delete per[name];
        copy[mid]=per;
      });
      return copy;
    });
  }

  function buildData(){
    return { roundName, matches, players, predictions, results, history };
  }
  function buildDataWithMeta(){
    const data = buildData();
    return { ...data, _updatedAt: new Date().toISOString(), _updatedBy: DEVICE_ID };
  }

  function exportData(){
    const data = buildData();
    navigator.clipboard.writeText(JSON.stringify(data,null,2)).then(()=>{
      alert('Данные скопированы в буфер обмена!');
    }).catch(()=>{
      alert('Скопируйте вручную из открывшегося окна.');
    });
    const json = JSON.stringify(data,null,2);
    const win = window.open('', '_blank', 'width=800,height=600');
    if(win){
      win.document.write(`<pre>${json.replace(/[<>&]/g, s=> ({'<':'&lt;','>':'&gt;','&':'&amp;'}[s]))}</pre>`);
      win.document.close();
    }
  }

  function applyImportedData(data){
    try{
      setRoundName(data.roundName ?? roundName);
      setMatches(Array.isArray(data.matches)? data.matches : []);
      setPlayers(Array.isArray(data.players)? data.players : players);
      setPredictions(data.predictions ?? {});
      setResults(data.results ?? {});
      setHistory(Array.isArray(data.history)? data.history : []);
    }catch(e){
      alert('Ошибка применения данных');
    }
  }

  function importData(){
    const raw = prompt('Вставьте JSON экспорт');
    if(!raw) return;
    try{
      const data = JSON.parse(raw);
      applyImportedData(data);
      alert('Импорт выполнен');
    }catch(e){
      alert('Некорректный JSON');
    }
  }

  async function createCloudLink(){
    try{
      const res = await fetch('https://jsonblob.com/api/jsonBlob', {
        method:'POST',
        headers:{
          'Content-Type':'application/json',
          'Accept':'application/json'
        },
        body: JSON.stringify(buildDataWithMeta()),
      });
      if(!res.ok) throw new Error(`Код ${res.status}`);
      const url = res.headers.get('Location');
      if(!url) throw new Error('Сервер не вернул ссылку');
      setCloudUrl(url);
      lastRemoteAtRef.current = new Date().toISOString();
      alert('Ссылка создана. Скопируйте её и храните в секрете.');
    }catch(e){
      alert('Не удалось создать ссылку: '+ e.message);
    }
  }

  async function saveToCloud(silent=false){
    if(!cloudUrl){ if(!silent) alert('Сначала вставьте/создайте ссылку'); return; }
    try{
      const data = buildDataWithMeta();
      const res = await fetch(cloudUrl, {
        method:'PUT',
        headers:{
          'Content-Type':'application/json',
          'Accept':'application/json'
        },
        body: JSON.stringify(data),
      });
      if(!res.ok) throw new Error(`Код ${res.status}`);
      lastRemoteAtRef.current = data._updatedAt;
      if(!silent) alert('Сохранено в облако');
    }catch(e){
      if(!silent) alert('Ошибка сохранения: '+ e.message);
    }
  }

  async function loadFromCloud(silent=false){
    if(!cloudUrl){ if(!silent) alert('Вставьте ссылку'); return; }
    try{
      const res = await fetch(cloudUrl, { cache:'no-store', headers:{'Accept':'application/json'} });
      if(!res.ok) throw new Error(`Код ${res.status}`);
      const data = await res.json();
      isApplyingRemoteRef.current = true;
      applyImportedData(data);
      lastRemoteAtRef.current = data?._updatedAt || null;
      isApplyingRemoteRef.current = false;
      if(!silent) alert('Загружено из облака');
    }catch(e){
      if(!silent) alert('Ошибка загрузки: '+ e.message);
    }
  }

  // Автосохранение (debounce 1с) при изменениях, если включена автосинхронизация
  useEffect(()=>{
    if(!autoSync || !cloudUrl) return;
    if(isApplyingRemoteRef.current) return;
    const handle = setTimeout(()=>{ saveToCloud(true); }, 1000);
    return ()=> clearTimeout(handle);
  }, [roundName, matches, players, predictions, results, history, cloudUrl, autoSync]);

  // Автообновление: опрос раз в 5с и при возврате на вкладку
  useEffect(()=>{
    if(!autoSync || !cloudUrl) return;
    let cancelled = false;
    let etag = null;

    async function poll(){
      if(cancelled) return;
      try{
        const headers = {'Accept':'application/json'};
        if(etag) headers['If-None-Match'] = etag;
        const res = await fetch(cloudUrl, { headers, cache:'no-store' });
        if(res.status === 304){
          // нет изменений
        }else if(res.ok){
          const newEtag = res.headers.get('ETag');
          if(newEtag) etag = newEtag;
          const remote = await res.json();
          const remoteAt = remote?._updatedAt || null;

          if(remoteAt && remoteAt !== lastRemoteAtRef.current){
            if(remote._updatedBy !== DEVICE_ID){
              isApplyingRemoteRef.current = true;
              applyImportedData(remote);
              lastRemoteAtRef.current = remoteAt;
              isApplyingRemoteRef.current = false;
            }else{
              lastRemoteAtRef.current = remoteAt;
            }
          }
        }
      }catch(e){
        // тихо игнорируем, попробуем позже
      } finally {
        if(!cancelled) setTimeout(poll, 5000);
      }
    }

    poll();
    const onVis = ()=>{ if(document.visibilityState === 'visible') poll(); };
    document.addEventListener('visibilitychange', onVis);

    return ()=>{
      cancelled = true;
      document.removeEventListener('visibilitychange', onVis);
    };
  }, [cloudUrl, autoSync]);

  const [tab,setTab] = useState('setup');

  return (
    <>
      <header>
        <h1>Прогнозы на футбол</h1>
        <div className="toolbar">
          <div className="round-name">
            <strong>Тур:</strong>
            <input value={roundName} onChange={e=>setRoundName(e.target.value)} placeholder="Название тура"/>
          </div>

          <button className="btn btn-ghost" onClick={exportData}>Экспорт</button>
          <button className="btn btn-ghost" onClick={importData}>Импорт</button>

          <div className="cloud-box">
            <input value={cloudUrl} onChange={e=>setCloudUrl(e.target.value)} placeholder="Ссылка для общего доступа (jsonblob)"/>
          </div>
          <button className="btn btn-ghost" onClick={createCloudLink}>Создать ссылку</button>
          <button className="btn btn-ghost" onClick={()=>loadFromCloud(false)}>Загрузить</button>
          <button className="btn btn-primary" onClick={()=>saveToCloud(false)}>Сохранить</button>

          <label className="chip">
            <input type="checkbox" checked={autoSync} onChange={e=>setAutoSync(e.target.checked)}/>
            &nbsp;Автосинхронизация
          </label>
        </div>
      </header>

      <nav className="tabs">
        {[
          ['setup','Матчи'],
          ['predictions','Прогнозы'],
          ['results','Результаты'],
          ['scores','Очки'],
          ['history','История'],
        ].map(([id,label])=>(
          <button key={id} className={`tab-btn ${tab===id?'active':''}`} onClick={()=>setTab(id)}>{label}</button>
        ))}
      </nav>

      {tab==='setup' && (
        <div className="grid grid-2">
          <div className="card">
            <h2>Список матчей</h2>
            <div className="row">
              <button className="btn btn-primary" onClick={addBlankMatch}>+ Матч</button>
              <button className="btn btn-ghost" onClick={()=>addBatch(5)}>+5</button>
              <button className="btn btn-ghost" onClick={()=>addBatch(10)}>+10</button>
              <button className="btn btn-danger" onClick={clearAll}>Очистить тур</button>
            </div>
            <table className="table">
              <thead>
              <tr>
                <th>#</th><th className="team">Команда 1</th><th className="team">Команда 2</th><th>Действия</th>
              </tr>
              </thead>
              <tbody>
              {matches.length===0 ? (
                <tr><td colSpan="4" className="muted">Добавьте матчи</td></tr>
              ) : matches.map((m,idx)=>(
                <tr key={m.id}>
                  <td>{idx+1}</td>
                  <td className="team"><input type="text" value={m.team1} onChange={e=>updateMatch(m.id,'team1',e.target.value)} placeholder="Команда 1"/></td>
                  <td className="team"><input type="text" value={m.team2} onChange={e=>updateMatch(m.id,'team2',e.target.value)} placeholder="Команда 2"/></td>
                  <td><button className="btn btn-ghost" onClick={()=>deleteMatch(m.id)}>Удалить</button></td>
                </tr>
              ))}
              </tbody>
            </table>
            <div className="space"></div>
            <div className="helper">Совет: можно сначала набросать список матчей, затем перейти во вкладку «Прогнозы».</div>
          </div>

          <div className="card">
            <h2>Игроки</h2>
            <PlayersManager players={players} addPlayer={addPlayer} removePlayer={removePlayer}/>
            <div className="space"></div>
            <h2>Сводка</h2>
            <div className="stack">
              <div className="chip">Матчей: <strong>{matches.length}</strong></div>
              <div className="chip">Игроков: <strong>{players.length}</strong></div>
              <div className="chip">Есть результаты: <strong>{Object.keys(results).filter(k=>Number.isInteger(results[k]?.score1)).length}</strong></div>
            </div>
          </div>
        </div>
      )}

      {tab==='predictions' && (
        <div className="card">
          <h2>Прогнозы</h2>
          <div className="row" style={{justifyContent:'space-between',alignItems:'flex-start'}}>
            <div className="stack" style={{flex:1}}>
              <div className="players">
                {players.map(p=>(
                  <button key={p} className={`player-btn ${currentPlayer===p?'active':''}`} onClick={()=>setCurrentPlayer(p)}>{p}</button>
                ))}
              </div>
              <div className="row">
                <CopyPredictions players={players} currentPlayer={currentPlayer} onCopy={copyFromPlayer}/>
                <button className="btn btn-ghost" onClick={()=>fillDefault(1,1)}>Всем 1:1</button>
                <button className="btn btn-ghost" onClick={()=>fillDefault(0,0)}>Всем 0:0</button>
                <button className="btn btn-danger" onClick={()=>clearPredictionsFor()}>Очистить прогнозы игрока</button>
              </div>
            </div>
            <div className="stack" style={{minWidth:240}}>
              <div className="chip">Текущие очки: <strong>{currentPoints[currentPlayer] ?? 0}</strong></div>
              <div className="chip">Итого (история): <strong>{totalPoints[currentPlayer] ?? 0}</strong></div>
            </div>
          </div>

          <table className="table">
            <thead>
            <tr>
              <th>#</th><th className="team">Матч</th><th>Прогноз {currentPlayer}</th><th>Результат</th><th>Очки</th>
            </tr>
            </thead>
            <tbody>
            {matches.length===0 ? (
              <tr><td colSpan="5" className="muted">Нет матчей. Добавьте их во вкладке «Матчи».</td></tr>
            ) : matches.map((m,idx)=>{
              const pred = predictions[m.id]?.[currentPlayer] || {};
              const res = results[m.id];
              const pts = pointsFor(pred,res);
              return (
                <tr key={m.id}>
                  <td>{idx+1}</td>
                  <td className="team"><strong>{m.team1||'—'}</strong> vs <strong>{m.team2||'—'}</strong></td>
                  <td>
                    <div className="row" style={{justifyContent:'center'}}>
                      <input type="number" min="0" value={Number.isInteger(pred.score1)?pred.score1:''}
                             onChange={e=>setPred(m.id,currentPlayer, parseIntSafe(e.target.value), pred.score2)}/>
                      <span>:</span>
                      <input type="number" min="0" value={Number.isInteger(pred.score2)?pred.score2:''}
                             onChange={e=>setPred(m.id,currentPlayer, pred.score1, parseIntSafe(e.target.value))}/>
                    </div>
                  </td>
                  <td>
                    <span className="muted">{Number.isInteger(res?.score1)?res.score1:'—'}:{Number.isInteger(res?.score2)?res.score2:'—'}</span>
                  </td>
                  <td>
                    {pts===3 && <span className="pill pill-ok">3</span>}
                    {pts===2 && <span className="pill pill-diff">2</span>}
                    {pts===1 && <span className="pill pill-warn">1</span>}
                    {pts===0 && <span className="pill pill-bad">0</span>}
                  </td>
                </tr>
              );
            })}
            </tbody>
          </table>
        </div>
      )}

      {tab==='results' && (
        <div className="card">
          <h2>Результаты</h2>
          <div className="row">
            <button className="btn btn-ok" onClick={finalizeRound}>Финализировать тур в историю</button>
            <button className="btn btn-danger" onClick={clearResults}>Очистить результаты</button>
          </div>
          <table className="table">
            <thead>
            <tr>
              <th>#</th><th className="team">Матч</th><th>Результат</th><th>Кто угадал</th>
            </tr>
            </thead>
            <tbody>
            {matches.length===0 ? (
              <tr><td colSpan="4" className="muted">Нет матчей</td></tr>
            ) : matches.map((m,idx)=>{
              const res = results[m.id] || {};
              const exact = players.filter(p=>{
                const pred = predictions[m.id]?.[p];
                return pointsFor(pred,res)===3;
              });
              return (
                <tr key={m.id}>
                  <td>{idx+1}</td>
                  <td className="team"><strong>{m.team1||'—'}</strong> vs <strong>{m.team2||'—'}</strong></td>
                  <td>
                    <div className="row" style={{justifyContent:'center'}}>
                      <input type="number" min="0" value={Number.isInteger(res.score1)?res.score1:''}
                             onChange={e=>setRes(m.id, parseIntSafe(e.target.value), res.score2)}/>
                      <span>:</span>
                      <input type="number" min="0" value={Number.isInteger(res.score2)?res.score2:''}
                             onChange={e=>setRes(m.id, res.score1, parseIntSafe(e.target.value))}/>
                    </div>
                  </td>
                  <td>
                    {exact.length>0 ? exact.join(', ') : <span className="muted">—</span>}
                  </td>
                </tr>
              );
            })}
            </tbody>
          </table>
          <div className="space"></div>
          <div className="helper">Подсказка: можно финализировать тур даже без результатов по всем матчам — в историю попадёт то, что введено.</div>
        </div>
      )}

      {tab==='scores' && (
        <div className="grid">
          <div className="card">
            <h2>Очки за текущий тур</h2>
            <table className="table">
              <thead><tr><th>Игрок</th><th>Очки</th></tr></thead>
              <tbody>
              {players.map(p=>(
                <tr key={p}><td>{p}</td><td><strong>{currentPoints[p] ?? 0}</strong></td></tr>
              ))}
              </tbody>
            </table>
          </div>
          <div className="card">
            <h2>Общий счёт (история)</h2>
            <table className="table">
              <thead><tr><th>Игрок</th><th>Очки</th></tr></thead>
              <tbody>
              {players.map(p=>(
                <tr key={p}><td>{p}</td><td><strong>{totalPoints[p] ?? 0}</strong></td></tr>
              ))}
              </tbody>
            </table>
          </div>
        </div>
      )}

      {tab==='history' && (
        <div className="card">
          <h2>История туров</h2>
          {history.length===0 ? (
            <div className="muted">История пуста</div>
          ):(
            <div className="stack">
              {history.map(round=>(
                <div key={round.id} className="card" style={{padding:'12px'}}>
                  <div className="row" style={{justifyContent:'space-between',alignItems:'center'}}>
                    <div className="row" style={{gap:12,alignItems:'baseline',flexWrap:'wrap'}}>
                      <strong>{round.roundName}</strong>
                      <span className="muted">{new Date(round.date).toLocaleString()}</span>
                      <span className="chip">Матчей: {round.matches.length}</span>
                    </div>
                    <button className="btn btn-ghost" onClick={()=>deleteHistoryRound(round.id)}>Удалить</button>
                  </div>
                  <div className="space"></div>
                  <table className="table">
                    <thead><tr><th>#</th><th className="team">Матч</th><th>Результат</th><th>Очки по игрокам</th></tr></thead>
                    <tbody>
                    {round.matches.map((m,idx)=>{
                      const res = round.results[m.id];
                      return (
                        <tr key={m.id}>
                          <td>{idx+1}</td>
                          <td className="team"><strong>{m.team1||'—'}</strong> vs <strong>{m.team2||'—'}</strong></td>
                          <td>{Number.isInteger(res?.score1)?res.score1:'—'}:{Number.isInteger(res?.score2)?res.score2:'—'}</td>
                          <td style={{textAlign:'left'}}>
                            <div className="row" style={{flexWrap:'wrap',gap:6,justifyContent:'flex-start'}}>
                              {players.map(p=>{
                                const pred = round.predictions[m.id]?.[p];
                                const pts = pointsFor(pred,res);
                                return <span key={p} className="chip">{p}: <strong>{pts}</strong></span>
                              })}
                            </div>
                          </td>
                        </tr>
                      );
                    })}
                    </tbody>
                  </table>
                  <div className="space"></div>
                  <div className="row" style={{flexWrap:'wrap',gap:8}}>
                    {players.map(p=>(
                      <span key={p} className="chip">{p}: <strong>{round.points[p] ?? 0}</strong></span>
                    ))}
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>
      )}
    </>
  );
}

function parseIntSafe(v){
  if(v==='' || v==null) return null;
  const n = Number(v);
  return Number.isFinite(n) && n>=0 ? Math.floor(n) : null;
}

function PlayersManager({players,addPlayer,removePlayer}){
  const [name,setName] = React.useState('');
  return (
    <div className="stack">
      <div className="row">
        <input className="table" style={{ width: 260 }} type="text" placeholder="Новый игрок"
               value={name} onChange={e=>setName(e.target.value)}/>
        <button className="btn btn-primary" onClick={()=>{ addPlayer(name); setName(''); }}>Добавить</button>
      </div>
      <div className="players">
        {players.map(p=>(
          <span key={p} className="chip">{p} <button className="btn btn-ghost" onClick={()=>removePlayer(p)}>×</button></span>
        ))}
      </div>
      <div className="helper">Подсказка: удаление игрока также очищает его прогнозы в текущем туре.</div>
    </div>
  );
}

function CopyPredictions({players,currentPlayer,onCopy}){
  const [src,setSrc] = React.useState('');
  React.useEffect(()=>{ setSrc(''); },[currentPlayer]);
  return (
    <div className="row">
      <select className="table" style={{ width: 180 }}
              value={src} onChange={e=>setSrc(e.target.value)}>
        <option value="">Копировать из...</option>
        {players.filter(p=>p!==currentPlayer).map(p=>(
          <option key={p} value={p}>{p}</option>
        ))}
      </select>
      <button className="btn btn-ghost" disabled={!src} onClick={()=>onCopy(src)}>Копировать</button>
    </div>
  );
}

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App/>);
</script>
</body>
</html>
