<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Прогнозы на футбол — Тур</title>
  <script src="https://unpkg.com/react@18.2.0/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone@7.22.9/babel.min.js"></script>
  <!-- Firebase (compat) -->
  <script src="https://www.gstatic.com/firebasejs/10.12.5/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore-compat.js"></script>
  <style>
    :root{
      --bg:#f5f7fb; --card:#fff; --text:#222; --muted:#667084;
      --brand:#0d6efd; --brand-2:#00bcd4; --ok:#19a974; --warn:#ff9800; --danger:#ef4444;
      --border:#e5e7eb; --shadow:0 6px 18px rgba(0,0,0,.06); --radius:14px; --radius-sm:10px;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif;
      background:linear-gradient(135deg,#e8f0ff,#f8fbff 40%,#eefaf7);color:var(--text)}
    .wrap{max-width:1100px;margin:0 auto;padding:20px 16px 60px}
    header{display:flex;align-items:center;justify-content:space-between;gap:16px;margin:10px 0 20px;flex-wrap:wrap}
    h1{margin:0;font-size:24px;font-weight:800;letter-spacing:.2px;background:linear-gradient(45deg,var(--brand),var(--brand-2));-webkit-background-clip:text;-webkit-text-fill-color:transparent}
    .toolbar{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    .round-name{display:flex;gap:8px;align-items:center;background:var(--card);border:1px solid var(--border);border-radius:999px;padding:8px 12px;box-shadow:var(--shadow)}
    .round-name input{border:none;outline:none;font-size:14px;background:transparent;min-width:200px}
    .cloud-box{display:flex;gap:8px;align-items:center;background:var(--card);border:1px solid var(--border);border-radius:999px;padding:8px 12px;box-shadow:var(--shadow)}
    .cloud-box input{border:none;outline:none;font-size:14px;background:transparent;min-width:220px}
    .tabs{display:flex;gap:8px;flex-wrap:wrap;margin:0 0 14px}
    .tab-btn{border:1px solid var(--border);background:var(--card);padding:10px 14px;border-radius:999px;cursor:pointer;font-weight:600;color:var(--muted)}
    .tab-btn.active{background:linear-gradient(45deg,var(--brand),var(--brand-2));color:#fff;border-color:transparent;box-shadow:var(--shadow)}
    .grid{display:grid;gap:16px}
    @media(min-width:900px){.grid-2{grid-template-columns:1.15fr .85fr}}
    .card{background:var(--card);border:1px solid var(--border);border-radius:var(--radius);box-shadow:var(--shadow);padding:14px}
    .card h2{margin:0 0 10px;font-size:18px}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .btn{border:none;border-radius:10px;padding:10px 14px;font-weight:700;cursor:pointer;display:inline-flex;gap:8px;align-items:center}
    .btn:disabled{opacity:.5;cursor:not-allowed}
    .btn-primary{background:linear-gradient(45deg,var(--brand),var(--brand-2));color:#fff;box-shadow:var(--shadow)}
    .btn-ghost{background:#fff;border:1px solid var(--border)}
    .btn-danger{background:linear-gradient(45deg,#ef5350,#ef4444);color:#fff}
    .btn-ok{background:linear-gradient(45deg,#22c55e,#16a34a);color:#fff}
    .chip{display:inline-flex;align-items:center;gap:6px;border:1px solid var(--border);border-radius:999px;padding:6px 10px;background:#fff;font-size:12px}
    .muted{color:var(--muted);font-size:12px}
    .table{width:100%;border-collapse:collapse;margin-top:4px}
    .table th,.table td{border-bottom:1px solid var(--border);padding:10px 8px;text-align:center}
    .table th{background:#f7fafc;font-size:12px;text-transform:uppercase;letter-spacing:.04em}
    .table input[type=number]{width:70px;padding:8px;border:1px solid var(--border);border-radius:10px;background:#fff}
    .table input[type=text]{width:100%;padding:8px;border:1px solid var(--border);border-radius:10px;background:#fff}
    .table .team{min-width:150px;text-align:left}
    .pill{display:inline-flex;align-items:center;gap:6px;border-radius:999px;padding:4px 8px;font-weight:700;font-size:12px}
    .pill-ok{background:#ecfdf5;color:#065f46}.pill-warn{background:#fff7ed;color:#9a3412}.pill-diff{background:#eef2ff;color:#3730a3}.pill-bad{background:#fef2f2;color:#991b1b}
    .stack{display:flex;flex-direction:column;gap:10px}
    .players{display:flex;gap:8px;flex-wrap:wrap}
    .player-btn{padding:8px 12px;border-radius:999px;border:1px solid var(--border);background:#fff;font-weight:700;cursor:pointer}
    .player-btn.active{background:var(--text);color:#fff;border-color:transparent}
    .space{height:8px}
  </style>
</head>
<body>
<div id="root" class="wrap"></div>
<script type="text/babel">
const {useState,useEffect,useMemo,useRef} = React;

// Firebase config (ваши данные)
const firebaseConfig = {
  apiKey: "AIzaSyAET0m2j5YyvXK9Gp4gxJbfZCqL6R42N8U",
  authDomain: "predict-8b1f4.firebaseapp.com",
  projectId: "predict-8b1f4",
  storageBucket: "predict-8b1f4.firebasestorage.app",
  messagingSenderId: "1086430765447",
  appId: "1:1086430765447:web:a85b5e8ff8392e55e93322"
};

firebase.initializeApp(firebaseConfig);
const db = firebase.firestore();
firebase.firestore().enablePersistence({synchronizeTabs:true}).catch(()=>{});

// Local keys
const STORAGE_KEYS = {
  round: 'fp_roundName',
  matches:'fp_matches',
  players:'fp_players',
  predictions:'fp_predictions',
  results:'fp_results',
  history:'fp_history',
  roomId:'fp_room_id',
};

function uid(){ return Math.random().toString(36).slice(2)+Date.now().toString(36); }
const DEVICE_ID_KEY = 'fp_device_id';
function getDeviceId(){
  try{
    let id = localStorage.getItem(DEVICE_ID_KEY);
    if(!id){ id = uid(); localStorage.setItem(DEVICE_ID_KEY, id); }
    return id;
  }catch{ return uid(); }
}
const DEVICE_ID = getDeviceId();

function getRoomFromQuery(){
  try{
    const p = new URLSearchParams(location.search);
    const r = (p.get('room')||'').trim();
    return r || null;
  }catch{ return null; }
}

function outcome(a,b){ if(a>b) return 1; if(a<b) return -1; return 0; }
function pointsFor(pred,res){
  if(pred==null || res==null) return 0;
  const {score1:ps1,score2:ps2} = pred||{};
  const {score1:rs1,score2:rs2} = res||{};
  if(ps1==null || ps2==null || rs1==null || rs2==null) return 0;
  if(ps1===rs1 && ps2===rs2) return 3;
  const sameOutcome = outcome(ps1,ps2)===outcome(rs1,rs2);
  const sameDiff = (ps1-ps2)===(rs1-rs2);
  if(sameDiff && sameOutcome) return 2;
  if(sameOutcome) return 1;
  return 0;
}

function usePersistentState(key, initial){
  const [state,setState] = useState(()=>{
    try{
      const raw = localStorage.getItem(key);
      return raw ? JSON.parse(raw) : initial;
    }catch{ return initial; }
  });
  useEffect(()=>{ try{ localStorage.setItem(key, JSON.stringify(state)); }catch{} },[key,state]);
  return [state,setState];
}

function App(){
  // Local state
  const [roundName,setRoundName] = usePersistentState(STORAGE_KEYS.round, 'Тур #1');
  const [matches,setMatches] = usePersistentState(STORAGE_KEYS.matches, []);
  const [players,setPlayers] = usePersistentState(STORAGE_KEYS.players, ['Виталий','Сергей','Грок']);
  const [currentPlayer,setCurrentPlayer] = useState(()=> players[0] || '');
  const [predictions,setPredictions] = usePersistentState(STORAGE_KEYS.predictions, {});
  const [results,setResults] = usePersistentState(STORAGE_KEYS.results, {});
  const [history,setHistory] = usePersistentState(STORAGE_KEYS.history, []);
  const [roomId,setRoomId] = usePersistentState(STORAGE_KEYS.roomId, getRoomFromQuery() || 'default');

  // Стабилизация ввода
  const isApplyingRemoteRef = useRef(false);
  const lastRemoteAtRef = useRef(null);
  const unsubRef = useRef(null);
  const hasInitialSyncRef = useRef(false);

  const focusedFieldRef = useRef(null);       // 'm:<id>:team1' | 'pred:<id>:p1' | etc
  const pendingRemoteRef = useRef(null);      // откладываемое удалённое состояние
  const lastLocalEditAtRef = useRef(0);       // когда последний раз редактировали
  const AUTOSAVE_DELAY_MS = 2000;             // подождать паузу
  const EDIT_GRACE_MS = 1200;                 // окно "печатаю" — не мешать

  const markEdited = ()=>{ lastLocalEditAtRef.current = Date.now(); };

  useEffect(()=>{
    const r = getRoomFromQuery();
    if(r && r!==roomId) setRoomId(r);
  },[]);

  useEffect(()=> { if(!players.includes(currentPlayer)) setCurrentPlayer(players[0] || ''); },[players]);

  // Local CRUD
  function addBlankMatch(){ markEdited(); setMatches(prev => [...prev, { id: uid(), team1:'', team2:'' }]); }
  function addBatch(n=5){
    markEdited();
    setMatches(prev=>{
      const list=[...prev];
      for(let i=0;i<n;i++) list.push({id:uid(),team1:'',team2:''});
      return list;
    });
  }
  function updateMatch(id, field, value){
    markEdited();
    setMatches(prev => prev.map(m => m.id===id ? {...m, [field]: value} : m));
  }
  function deleteMatch(id){
    if(!confirm('Удалить матч?')) return;
    markEdited();
    setMatches(prev => prev.filter(m => m.id!==id));
    setPredictions(prev => { const copy = {...prev}; delete copy[id]; return copy; });
    setResults(prev => { const copy = {...prev}; delete copy[id]; return copy; });
  }
  function clearAll(){
    if(!confirm('Очистить все матчи, прогнозы и результаты текущего тура?')) return;
    markEdited();
    setMatches([]); setPredictions({}); setResults({});
  }
  function setPred(matchId, player, score1, score2){
    markEdited();
    setPredictions(prev=>{
      const m = prev[matchId] ? {...prev[matchId]} : {};
      m[player] = { score1, score2 };
      return { ...prev, [matchId]: m };
    });
  }
  function setRes(matchId, score1, score2){
    markEdited();
    setResults(prev=> ({ ...prev, [matchId]: { score1, score2 } }));
  }
  function copyFromPlayer(source){
    if(!source || source===currentPlayer) return;
    markEdited();
    setPredictions(prev=>{
      const copy = {...prev};
      matches.forEach(m=>{
        const src = copy[m.id]?.[source];
        if(src){
          const perMatch = copy[m.id] ? {...copy[m.id]} : {};
          perMatch[currentPlayer] = { ...src };
          copy[m.id] = perMatch;
        }
      });
      return copy;
    });
  }
  function fillDefault(s1,s2){
    markEdited();
    setPredictions(prev=>{
      const copy = {...prev};
      matches.forEach(m=>{
        const perMatch = copy[m.id] ? {...copy[m.id]} : {};
        perMatch[currentPlayer] = { score1:s1, score2:s2 };
        copy[m.id]=perMatch;
      });
      return copy;
    });
  }
  function clearPredictionsFor(playerName = currentPlayer){
    if(!playerName) return;
    markEdited();
    setPredictions(prev=>{
      const copy = {...prev};
      matches.forEach(m=>{
        if(copy[m.id]){
          const perMatch = {...copy[m.id]};
          delete perMatch[playerName];
          copy[m.id] = perMatch;
        }
      });
      return copy;
    });
  }
  function clearResults(){ if(!confirm('Очистить все результаты текущего тура?')) return; markEdited(); setResults({}); }

  // Players
  function addPlayer(name){
    const n = (name || '').trim();
    if(!n) return;
    if(players.includes(n)){ alert('Такой игрок уже есть'); return; }
    markEdited();
    setPlayers(prev => [...prev, n]);
  }
  function removePlayer(name){
    if(!confirm(`Удалить игрока "${name}"?`)) return;
    markEdited();
    setPlayers(prev => prev.filter(p => p!==name));
    setPredictions(prev=>{
      const copy = {...prev};
      Object.keys(copy).forEach(mid=>{
        const per = { ...(copy[mid]||{}) };
        delete per[name];
        copy[mid]=per;
      });
      return copy;
    });
  }

  // Points
  const currentPoints = useMemo(()=>{
    const score = Object.fromEntries(players.map(p=>[p,0]));
    matches.forEach(m=>{
      const res = results[m.id];
      players.forEach(p=>{
        const pred = predictions[m.id]?.[p];
        score[p] += pointsFor(pred,res);
      });
    });
    return score;
  },[players,matches,results,predictions]);

  const totalPoints = useMemo(()=>{
    const score = Object.fromEntries(players.map(p=>[p,0]));
    history.forEach(round=>{
      const playedPlayers = Object.keys(round.points || {});
      playedPlayers.forEach(p=>{
        if(score[p]==null) score[p]=0;
        score[p]+= round.points[p] || 0;
      });
    });
    return score;
  },[history,players]);

  function finalizeRound(){
    if(matches.length===0){ alert('Нет матчей в туре'); return; }
    const hasAnyResult = matches.some(m => results[m.id] && Number.isInteger(results[m.id].score1) && Number.isInteger(results[m.id].score2));
    if(!hasAnyResult){ alert('Сначала введите результаты матчей'); return; }

    const points = Object.fromEntries(players.map(p=>[p,0]));
    matches.forEach(m=>{
      const res = results[m.id];
      players.forEach(p=>{
        const pred = predictions[m.id]?.[p];
        points[p]+= pointsFor(pred,res);
      });
    });

    const round = {
      id: uid(),
      roundName: roundName || `Тур от ${new Date().toLocaleDateString()}`,
      date: new Date().toISOString(),
      matches: matches.map(m=>({ ...m })),
      results: JSON.parse(JSON.stringify(results)),
      predictions: JSON.parse(JSON.stringify(predictions)),
      points
    };
    markEdited();
    setHistory(prev=> [round, ...prev]);
    setMatches([]); setPredictions({}); setResults({});
    const next = roundName.replace(/#(\d+)/, (_,n)=>`#${Number(n)+1}`);
    setRoundName(next===roundName ? `${roundName} (след.)` : next);
    alert('Тур зафиксирован и перенесён в историю!');
  }

  function deleteHistoryRound(roundId){
    if(!confirm('Удалить запись истории тура?')) return;
    markEdited();
    setHistory(prev => prev.filter(r => r.id!==roundId));
  }

  // Serialize
  function buildData(){ return { roundName, matches, players, predictions, results, history }; }
  function buildDataWithMeta(){
    const data = buildData();
    return { ...data, _updatedAt: new Date().toISOString(), _updatedBy: DEVICE_ID };
  }
  function applyImportedData(data){
    try{
      setRoundName(data.roundName ?? roundName);
      setMatches(Array.isArray(data.matches)? data.matches : []);
      setPlayers(Array.isArray(data.players)? data.players : players);
      setPredictions(data.predictions ?? {});
      setResults(data.results ?? {});
      setHistory(Array.isArray(data.history)? data.history : []);
    }catch(e){
      alert('Ошибка применения данных');
    }
  }

  // Firestore realtime
  useEffect(()=>{
    if (unsubRef.current) { unsubRef.current(); unsubRef.current = null; }
    hasInitialSyncRef.current = false;

    const rid = (roomId || 'default').trim();
    if(!rid) return;

    const ref = db.collection('rooms').doc(rid);

    unsubRef.current = ref.onSnapshot(async (snap)=>{
      const exists = snap.exists;

      // Если печатаем — не трогаем UI, откладываем состояние
      const editingNow = focusedFieldRef.current != null || (Date.now() - lastLocalEditAtRef.current) < EDIT_GRACE_MS;

      if(!hasInitialSyncRef.current){
        hasInitialSyncRef.current = true;
        if(exists){
          const remote = snap.data() || {};
          if(editingNow){
            pendingRemoteRef.current = remote;
          }else{
            isApplyingRemoteRef.current = true;
            applyImportedData(remote);
            lastRemoteAtRef.current = remote?._updatedAt || null;
            isApplyingRemoteRef.current = false;
          }
        } else {
          try{ await ref.set(buildDataWithMeta()); }catch(e){ console.warn('init set error', e); }
        }
        return;
      }

      if(exists){
        const remote = snap.data() || {};
        const remoteAt = remote?._updatedAt || null;
        if(remoteAt && remoteAt !== lastRemoteAtRef.current){
          if(remote._updatedBy !== DEVICE_ID){
            if(editingNow){
              // отложим до окончания ввода
              pendingRemoteRef.current = remote;
            }else{
              isApplyingRemoteRef.current = true;
              applyImportedData(remote);
              lastRemoteAtRef.current = remoteAt;
              isApplyingRemoteRef.current = false;
            }
          }else{
            lastRemoteAtRef.current = remoteAt;
          }
        }
      }
    });

    return ()=>{ if (unsubRef.current) { unsubRef.current(); unsubRef.current = null; } };
  },[roomId]);

  // Autosave (debounce ~2s), не сохраняем пока печатают
  useEffect(()=>{
    if(!hasInitialSyncRef.current) return;
    if(isApplyingRemoteRef.current) return;

    const editingNow = focusedFieldRef.current != null || (Date.now() - lastLocalEditAtRef.current) < EDIT_GRACE_MS;
    if(editingNow) return;

    const handle = setTimeout(async ()=>{
      try{
        const rid = (roomId || 'default').trim();
        if(!rid) return;
        await db.collection('rooms').doc(rid).set(buildDataWithMeta(), {merge:true});
      }catch(e){ console.warn('autosave error', e); }
    }, AUTOSAVE_DELAY_MS);

    return ()=> clearTimeout(handle);
  }, [roundName, matches, players, predictions, results, history, roomId]);

  // Когда пользователь завершил ввод (blur) — применяем отложенные удалённые данные
  function handleBlur(){
    focusedFieldRef.current = null;
    setTimeout(()=>{
      if(pendingRemoteRef.current){
        const remote = pendingRemoteRef.current;
        pendingRemoteRef.current = null;
        isApplyingRemoteRef.current = true;
        applyImportedData(remote);
        lastRemoteAtRef.current = remote?._updatedAt || null;
        isApplyingRemoteRef.current = false;
      }
    }, 50);
  }

  // UI
  const [tab,setTab] = useState('setup');

  function shareLink(){
    const url = new URL(location.href);
    url.searchParams.set('room', roomId || 'default');
    navigator.clipboard.writeText(url.toString()).then(()=>{
      alert('Ссылка скопирована. Откройте её на других устройствах.');
    }).catch(()=>{
      prompt('Скопируйте ссылку:', url.toString());
    });
  }

  return (
    <>
      <header>
        <h1>Прогнозы на футбол</h1>
        <div className="toolbar">
          <div className="round-name">
            <strong>Тур:</strong>
            <input
              value={roundName}
              onChange={e=>{ setRoundName(e.target.value); markEdited(); }}
              onFocus={()=>{ focusedFieldRef.current='roundName'; }}
              onBlur={handleBlur}
              placeholder="Название тура"
            />
          </div>

          <div className="cloud-box">
            <strong>Код комнаты:</strong>
            <input
              value={roomId}
              onChange={e=>{ setRoomId(e.target.value.trim()); markEdited(); }}
              onFocus={()=>{ focusedFieldRef.current='roomId'; }}
              onBlur={handleBlur}
              placeholder="например, liga"
            />
            <button className="btn btn-ghost" onClick={shareLink}>Скопировать ссылку</button>
          </div>
        </div>
      </header>

      <nav className="tabs">
        {[
          ['setup','Матчи'],
          ['predictions','Прогнозы'],
          ['results','Результаты'],
          ['scores','Очки'],
          ['history','История'],
        ].map(([id,label])=>(
          <button key={id} className={`tab-btn ${tab===id?'active':''}`} onClick={()=>setTab(id)}>{label}</button>
        ))}
      </nav>

      {tab==='setup' && (
        <div className="grid grid-2">
          <div className="card">
            <h2>Список матчей</h2>
            <div className="row">
              <button className="btn btn-primary" onClick={addBlankMatch}>+ Матч</button>
              <button className="btn btn-ghost" onClick={()=>addBatch(5)}>+5</button>
              <button className="btn btn-ghost" onClick={()=>addBatch(10)}>+10</button>
              <button className="btn btn-danger" onClick={clearAll}>Очистить тур</button>
            </div>
            <table className="table">
              <thead>
              <tr>
                <th>#</th><th className="team">Команда 1</th><th className="team">Команда 2</th><th>Действия</th>
              </tr>
              </thead>
              <tbody>
              {matches.length===0 ? (
                <tr><td colSpan="4" className="muted">Добавьте матчи</td></tr>
              ) : matches.map((m,idx)=>(
                <tr key={m.id}>
                  <td>{idx+1}</td>
                  <td className="team">
                    <input type="text"
                      value={m.team1}
                      onChange={e=>updateMatch(m.id,'team1',e.target.value)}
                      onFocus={()=>{ focusedFieldRef.current=`m:${m.id}:team1`; }}
                      onBlur={handleBlur}
                      placeholder="Команда 1"/>
                  </td>
                  <td className="team">
                    <input type="text"
                      value={m.team2}
                      onChange={e=>updateMatch(m.id,'team2',e.target.value)}
                      onFocus={()=>{ focusedFieldRef.current=`m:${m.id}:team2`; }}
                      onBlur={handleBlur}
                      placeholder="Команда 2"/>
                  </td>
                  <td><button className="btn btn-ghost" onClick={()=>deleteMatch(m.id)}>Удалить</button></td>
                </tr>
              ))}
              </tbody>
            </table>
            <div className="space"></div>
            <div className="muted">Можно добавлять сколько нужно матчей; данные сохраняются после небольшой паузы.</div>
          </div>

          <div className="card">
            <h2>Игроки</h2>
            <PlayersManager players={players} addPlayer={addPlayer} removePlayer={removePlayer}/>
            <div className="space"></div>
            <h2>Сводка</h2>
            <div className="stack">
              <div className="chip">Матчей: <strong>{matches.length}</strong></div>
              <div className="chip">Игроков: <strong>{players.length}</strong></div>
              <div className="chip">Есть результаты: <strong>{Object.keys(results).filter(k=>Number.isInteger(results[k]?.score1)).length}</strong></div>
            </div>
          </div>
        </div>
      )}

      {tab==='predictions' && (
        <div className="card">
          <h2>Прогнозы</h2>
          <div className="row" style={{justifyContent:'space-between',alignItems:'flex-start'}}>
            <div className="stack" style={{flex:1}}>
              <div className="players">
                {players.map(p=>(
                  <button key={p} className={`player-btn ${currentPlayer===p?'active':''}`} onClick={()=>setCurrentPlayer(p)}>{p}</button>
                ))}
              </div>
              <div className="row">
                <CopyPredictions players={players} currentPlayer={currentPlayer} onCopy={copyFromPlayer}/>
                <button className="btn btn-ghost" onClick={()=>fillDefault(1,1)}>Всем 1:1</button>
                <button className="btn btn-ghost" onClick={()=>fillDefault(0,0)}>Всем 0:0</button>
                <button className="btn btn-danger" onClick={()=>clearPredictionsFor()}>Очистить прогнозы игрока</button>
              </div>
            </div>
            <div className="stack" style={{minWidth:240}}>
              <div className="chip">Текущие очки: <strong>{currentPoints[currentPlayer] ?? 0}</strong></div>
              <div className="chip">Итого (история): <strong>{totalPoints[currentPlayer] ?? 0}</strong></div>
            </div>
          </div>

          <table className="table">
            <thead>
            <tr>
              <th>#</th><th className="team">Матч</th><th>Прогноз {currentPlayer}</th><th>Результат</th><th>Очки</th>
            </tr>
            </thead>
            <tbody>
            {matches.length===0 ? (
              <tr><td colSpan="5" className="muted">Нет матчей. Добавьте их во вкладке «Матчи».</td></tr>
            ) : matches.map((m,idx)=>{
              const pred = predictions[m.id]?.[currentPlayer] || {};
              const res = results[m.id];
              const pts = pointsFor(pred,res);
              return (
                <tr key={m.id}>
                  <td>{idx+1}</td>
                  <td className="team"><strong>{m.team1||'—'}</strong> vs <strong>{m.team2||'—'}</strong></td>
                  <td>
                    <div className="row" style={{justifyContent:'center'}}>
                      <input type="number" min="0"
                        value={Number.isInteger(pred.score1)?pred.score1:''}
                        onChange={e=>setPred(m.id,currentPlayer, parseIntSafe(e.target.value), pred.score2)}
                        onFocus={()=>{ focusedFieldRef.current=`pred:${m.id}:p1`; }}
                        onBlur={handleBlur}
                      />
                      <span>:</span>
                      <input type="number" min="0"
                        value={Number.isInteger(pred.score2)?pred.score2:''}
                        onChange={e=>setPred(m.id,currentPlayer, pred.score1, parseIntSafe(e.target.value))}
                        onFocus={()=>{ focusedFieldRef.current=`pred:${m.id}:p2`; }}
                        onBlur={handleBlur}
                      />
                    </div>
                  </td>
                  <td>
                    <span className="muted">{Number.isInteger(res?.score1)?res.score1:'—'}:{Number.isInteger(res?.score2)?res.score2:'—'}</span>
                  </td>
                  <td>
                    {pts===3 && <span className="pill pill-ok">3</span>}
                    {pts===2 && <span className="pill pill-diff">2</span>}
                    {pts===1 && <span className="pill pill-warn">1</span>}
                    {pts===0 && <span className="pill pill-bad">0</span>}
                  </td>
                </tr>
              );
            })}
            </tbody>
          </table>
        </div>
      )}

      {tab==='results' && (
        <div className="card">
          <h2>Результаты</h2>
          <div className="row">
            <button className="btn btn-ok" onClick={finalizeRound}>Финализировать тур в историю</button>
            <button className="btn btn-danger" onClick={clearResults}>Очистить результаты</button>
          </div>
          <table className="table">
            <thead>
            <tr>
              <th>#</th><th className="team">Матч</th><th>Результат</th><th>Кто угадал</th>
            </tr>
            </thead>
            <tbody>
            {matches.length===0 ? (
              <tr><td colSpan="4" className="muted">Нет матчей</td></tr>
            ) : matches.map((m,idx)=>{
              const res = results[m.id] || {};
              const exact = players.filter(p=>{
                const pred = predictions[m.id]?.[p];
                return pointsFor(pred,res)===3;
              });
              return (
                <tr key={m.id}>
                  <td>{idx+1}</td>
                  <td className="team"><strong>{m.team1||'—'}</strong> vs <strong>{m.team2||'—'}</strong></td>
                  <td>
                    <div className="row" style={{justifyContent:'center'}}>
                      <input type="number" min="0"
                        value={Number.isInteger(res.score1)?res.score1:''}
                        onChange={e=>setRes(m.id, parseIntSafe(e.target.value), res.score2)}
                        onFocus={()=>{ focusedFieldRef.current=`res:${m.id}:r1`; }}
                        onBlur={handleBlur}
                      />
                      <span>:</span>
                      <input type="number" min="0"
                        value={Number.isInteger(res.score2)?res.score2:''}
                        onChange={e=>setRes(m.id, res.score1, parseIntSafe(e.target.value))}
                        onFocus={()=>{ focusedFieldRef.current=`res:${m.id}:r2`; }}
                        onBlur={handleBlur}
                      />
                    </div>
                  </td>
                  <td>
                    {exact.length>0 ? exact.join(', ') : <span className="muted">—</span>}
                  </td>
                </tr>
              );
            })}
            </tbody>
          </table>
          <div className="space"></div>
          <div className="muted">Изменения синхронизируются после паузы; ввод не будет сбрасываться во время печати.</div>
        </div>
      )}

      {tab==='scores' && (
        <div className="grid">
          <div className="card">
            <h2>Очки за текущий тур</h2>
            <table className="table">
              <thead><tr><th>Игрок</th><th>Очки</th></tr></thead>
              <tbody>
              {players.map(p=>(
                <tr key={p}><td>{p}</td><td><strong>{currentPoints[p] ?? 0}</strong></td></tr>
              ))}
              </tbody>
            </table>
          </div>
          <div className="card">
            <h2>Общий счёт (история)</h2>
            <table className="table">
              <thead><tr><th>Игрок</th><th>Очки</th></tr></thead>
              <tbody>
              {players.map(p=>(
                <tr key={p}><td>{p}</td><td><strong>{totalPoints[p] ?? 0}</strong></td></tr>
              ))}
              </tbody>
            </table>
          </div>
        </div>
      )}

      {tab==='history' && (
        <div className="card">
          <h2>История туров</h2>
          {history.length===0 ? (
            <div className="muted">История пуста</div>
          ):(
            <div className="stack">
              {history.map(round=>(
                <div key={round.id} className="card" style={{padding:'12px'}}>
                  <div className="row" style={{justifyContent:'space-between',alignItems:'center'}}>
                    <div className="row" style={{gap:12,alignItems:'baseline',flexWrap:'wrap'}}>
                      <strong>{round.roundName}</strong>
                      <span className="muted">{new Date(round.date).toLocaleString()}</span>
                      <span className="chip">Матчей: {round.matches.length}</span>
                    </div>
                    <button className="btn btn-ghost" onClick={()=>deleteHistoryRound(round.id)}>Удалить</button>
                  </div>
                  <div className="space"></div>
                  <table className="table">
                    <thead><tr><th>#</th><th className="team">Матч</th><th>Результат</th><th>Очки по игрокам</th></tr></thead>
                    <tbody>
                    {round.matches.map((m,idx)=>{
                      const res = round.results[m.id];
                      return (
                        <tr key={m.id}>
                          <td>{idx+1}</td>
                          <td className="team"><strong>{m.team1||'—'}</strong> vs <strong>{m.team2||'—'}</strong></td>
                          <td>{Number.isInteger(res?.score1)?res.score1:'—'}:{Number.isInteger(res?.score2)?res.score2:'—'}</td>
                          <td style={{textAlign:'left'}}>
                            <div className="row" style={{flexWrap:'wrap',gap:6,justifyContent:'flex-start'}}>
                              {players.map(p=>{
                                const pred = round.predictions[m.id]?.[p];
                                const pts = pointsFor(pred,res);
                                return <span key={p} className="chip">{p}: <strong>{pts}</strong></span>
                              })}
                            </div>
                          </td>
                        </tr>
                      );
                    })}
                    </tbody>
                  </table>
                  <div className="space"></div>
                  <div className="row" style={{flexWrap:'wrap',gap:8}}>
                    {players.map(p=>(
                      <span key={p} className="chip">{p}: <strong>{round.points[p] ?? 0}</strong></span>
                    ))}
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>
      )}
    </>
  );
}

function parseIntSafe(v){
  if(v==='' || v==null) return null;
  const n = Number(v);
  return Number.isFinite(n) && n>=0 ? Math.floor(n) : null;
}

function PlayersManager({players,addPlayer,removePlayer}){
  const [name,setName] = React.useState('');
  return (
    <div className="stack">
      <div className="row">
        <input className="table" style={{ width: 260 }} type="text" placeholder="Новый игрок"
               value={name}
               onChange={e=>setName(e.target.value)}
        />
        <button className="btn btn-primary" onClick={()=>{ addPlayer(name); setName(''); }}>Добавить</button>
      </div>
      <div className="players">
        {players.map(p=>(
          <span key={p} className="chip">{p} <button className="btn btn-ghost" onClick={()=>removePlayer(p)}>×</button></span>
        ))}
      </div>
      <div className="muted">Удаление игрока очищает его прогнозы в текущем туре.</div>
    </div>
  );
}

function CopyPredictions({players,currentPlayer,onCopy}){
  const [src,setSrc] = React.useState('');
  React.useEffect(()=>{ setSrc(''); },[currentPlayer]);
  return (
    <div className="row">
      <select className="table" style={{ width: 180 }}
              value={src} onChange={e=>setSrc(e.target.value)}>
        <option value="">Копировать из...</option>
        {players.filter(p=>p!==currentPlayer).map(p=>(
          <option key={p} value={p}>{p}</option>
        ))}
      </select>
      <button className="btn btn-ghost" disabled={!src} onClick={()=>onCopy(src)}>Копировать</button>
    </div>
  );
}

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App/>);
</script>
</body>
</html>
